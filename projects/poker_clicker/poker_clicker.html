<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Poker Starting-Hand Clicker</title>
  <style>
    :root { 
      --cell: 54px; --gap: 4px; --radius: 8px;
      /* Color Palette */
      --color-dark: #2d3748;
      --color-mid-dark: #4a5568;
      --color-mid: #718096;
      --color-light: #e2e8f0;
      --color-lighter: #edf2f7;
      --color-lightest: #f7fafc;
      --color-white: #ffffff;
      /* Semantic Colors */
      --color-high-roll: linear-gradient(135deg, #10b981, #059669);
      --color-expected: linear-gradient(135deg, #3b82f6, #2563eb);
      --color-low-roll: linear-gradient(135deg, #f59e0b, #d97706);
      /* Typography */
      --font-size-banner: 24px;
      --font-size-large: 20px;
      --font-size-body: 14px;
      --font-size-label: 12px;
      --font-size-cell: 11px;
      --font-weight-bold: 700;
      --font-weight-semibold: 600;
      --font-weight-medium: 500;
      --font-weight-normal: 400;
      /* Shadows */
      --shadow-hero: 0 20px 60px rgba(0,0,0,0.3);
      --shadow-elevated: 0 4px 12px rgba(0,0,0,0.3);
      --shadow-subtle: 0 2px 8px rgba(0,0,0,0.1);
      /* Transitions */
      --transition-micro: 0.15s ease;
      --transition-standard: 0.2s ease;
      --transition-smooth: 0.3s ease;
    }
    * { box-sizing: border-box; }
    html, body { min-height: 100%; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      margin: 0; 
      padding: 20px;
      background: var(--color-lightest); 
      color: var(--color-dark); 
      display: flex; 
      justify-content: center; 
      align-items: flex-start;
      -webkit-text-size-adjust: none; 
      text-size-adjust: none; 
    }

    .app-container { 
      width: 100%; 
      max-width: 900px;
      background: var(--color-white);
      border-radius: 12px;
      padding: 20px;
      box-shadow: var(--shadow-hero);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    #topbar { 
      position: sticky; 
      top: 0; 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      padding: 12px 16px;
      background: var(--color-white);
      border-radius: 8px;
      box-shadow: var(--shadow-subtle);
      z-index: 10; 
    }
    #topbar-buttons { display: flex; gap: 12px; }
    
    #stats-bar {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: rgba(74, 85, 104, 0.9);
      backdrop-filter: blur(8px);
      border-radius: 8px;
      z-index: 9;
      margin-top: -8px;
      gap: 16px;
    }
    
    .stat-item {
      color: var(--color-white);
      font-size: 16px;
      font-weight: var(--font-weight-semibold);
    }
    
    #play-style-indicator {
      color: var(--color-white);
      font-size: 14px;
      font-weight: var(--font-weight-medium);
      padding: 6px 12px;
      border-radius: 12px;
      background: #3b82f6;
      transition: var(--transition-standard);
    }
    
    #play-style-indicator.normal {
      background: #10b981;
    }
    
    #play-style-indicator.loose {
      background: #f59e0b;
    }
    
    #view-tabs {
      display: flex;
      gap: 4px;
      background: var(--color-lighter);
      border-radius: 8px;
      padding: 4px;
    }
    
    .view-tab {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: var(--color-mid);
      font-weight: var(--font-weight-medium);
      transition: var(--transition-standard);
      cursor: pointer;
    }
    
    .view-tab.active {
      background: var(--color-white);
      color: var(--color-dark);
      box-shadow: var(--shadow-subtle);
    }
    
    .view-tab:hover:not(.active) {
      background: rgba(255, 255, 255, 0.5);
    }
    #total { 
      font-weight: var(--font-weight-semibold); 
      font-size: var(--font-size-large); 
      padding: 12px 16px; 
      background: var(--color-lightest); 
      border: 1px solid var(--color-light); 
      border-radius: 20px; 
      color: var(--color-dark);
    }
    button { 
      padding: 10px 14px; 
      border: 1px solid var(--color-light); 
      border-radius: 6px; 
      background: var(--color-white); 
      color: var(--color-dark);
      font-weight: var(--font-weight-medium);
      font-size: var(--font-size-body);
      cursor: pointer; 
      transition: var(--transition-standard);
      -webkit-tap-highlight-color: transparent; 
      touch-action: manipulation; 
    }
    button:hover {
      transform: translateY(-1px);
      background: var(--color-lighter);
    }
    button:active { 
      transform: translateY(0); 
    }
    
    button.toggle-active {
      background: var(--color-mid-dark) !important;
      color: var(--color-white) !important;
      border-color: var(--color-mid-dark) !important;
    }
    
    button.toggle-active:hover {
      background: var(--color-dark) !important;
      border-color: var(--color-dark) !important;
    }

    #grid-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }
    
    #list-container {
      display: none;
      flex-direction: column;
      gap: 12px;
      max-height: 60vh;
      overflow-y: auto;
    }
    
    #list-container.active {
      display: flex;
    }
    
    .list-item {
      display: flex;
      align-items: center;
      min-height: 56px;
      padding: 8px 16px;
      background: var(--color-white);
      border: 1px solid var(--color-light);
      border-radius: 8px;
      transition: var(--transition-standard);
      position: relative;
      gap: 12px;
    }
    
    .list-item:nth-child(even) {
      background: var(--color-lightest);
    }
    
    .list-item-hand {
      font-weight: var(--font-weight-semibold);
      font-size: 16px;
      min-width: 60px;
    }
    
    .list-item-position {
      flex: 1;
      text-align: center;
      color: var(--color-mid);
      font-size: 14px;
    }
    
    .list-item-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }
    
    .action-button {
      padding: 6px 12px;
      border: 1px solid var(--color-light);
      border-radius: 4px;
      background: var(--color-white);
      color: var(--color-dark);
      font-size: 12px;
      cursor: pointer;
      transition: var(--transition-micro);
      white-space: nowrap;
    }
    
    .action-button:hover {
      background: var(--color-lighter);
    }
    
    .action-button.played {
      background: #10b981;
      color: white;
      border-color: #10b981;
    }
    
    .action-button.folded {
      background: #9CA3AF;
      color: white;
      border-color: #9CA3AF;
    }
    
    .delete-button {
      padding: 6px 8px;
      border: 1px solid #ef4444;
      border-radius: 4px;
      background: #ef4444;
      color: white;
      cursor: pointer;
      transition: var(--transition-micro);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    
    .delete-button:hover {
      background: #dc2626;
      border-color: #dc2626;
    }
    
    

    #grid { width: 100%; display: grid; grid-template-columns: repeat(13, var(--cell)); grid-auto-rows: var(--cell); gap: var(--gap); min-width: 0; justify-content: center; }

    .cell { 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      text-align: center; 
      border: 1px solid var(--color-light); 
      border-radius: var(--radius); 
      background: var(--color-white); 
      color: var(--color-dark);
      user-select: none; 
      cursor: pointer; 
      transition: var(--transition-micro); 
      font-size: var(--font-size-cell); 
      font-weight: var(--font-weight-normal);
      padding: 0; 
      line-height: 1.05; 
      min-width: var(--cell); 
      min-height: var(--cell); 
      white-space: nowrap; 
      overflow: hidden; 
    }
    .cell.pair { 
      font-weight: var(--font-weight-semibold); 
    }
    .cell:active { 
      transform: scale(0.98); 
    }
    .cell.active { 
      opacity: 0.3;
    }
    
    /* Overlay only visible on mobile devices */
    @media (hover: none) and (pointer: coarse) {
      #magnify-overlay {
        position: fixed;
        width: var(--cell);
        height: var(--cell);
        display: none;
        align-items: center;
        justify-content: center;
        text-align: center;
        border: 1px solid var(--color-light);
        border-radius: var(--radius);
        background: var(--color-white);
        color: var(--color-dark);
        font-size: var(--font-size-cell);
        font-weight: var(--font-weight-normal);
        line-height: 1.05;
        white-space: nowrap;
        overflow: hidden;
        pointer-events: none;
        z-index: 1000;
        transform: scale(2.0) translateY(-40px);
        transform-origin: center center;
        box-shadow: var(--shadow-elevated);
        transition: none;
        will-change: transform;
      }
    }
    
    /* Hide overlay on desktop */
    @media (hover: hover) and (pointer: fine) {
      #magnify-overlay {
        display: none !important;
      }
    }
    
    
    .cell.played {
      position: relative;
    }
    
    .cell.played::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 2px;
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      border: 1px solid var(--color-white);
    }
    
    @media (max-width: 767px) {
      .cell.played::after {
        width: 5px;
        height: 5px;
        top: 1px;
        right: 1px;
        border-width: 0.5px;
      }
    }
    
    .cell.playing {
      animation: playingPulse 0.3s ease-in-out;
      background: rgba(16, 185, 129, 0.2) !important;
    }
    
    @keyframes playingPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }


    .note { 
      font-size: var(--font-size-label); 
      color: var(--color-mid); 
      font-weight: var(--font-weight-normal);
      text-align: left;
      max-width: 600px;
      line-height: 1.4;
      margin-top: auto;
      padding-top: 16px;
      border-top: 1px solid var(--color-light);
    }
    
    @media (max-width: 767px) {
      .note {
        font-size: 10px;
        line-height: 1.3;
        padding-top: 12px;
        margin-top: 16px;
      }
    }

    #toggle-controls {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    /* Responsive Breakpoints */
    @media (max-width: 479px) {
      body { padding: 0; }
      .app-container { 
        padding: 12px; 
        border-radius: 0;
        box-shadow: none;
      }
      #topbar { padding: 8px 12px; }
    }
    
    @media (min-width: 480px) and (max-width: 767px) {
      body { padding: 20px; }
    }
    
    @media (min-width: 768px) {
      body { padding: 24px; }
    }
    
    @media (min-width: 1200px) {
      .app-container { max-width: 900px; }
    }

    .results {
        padding: 20px;
        background: var(--color-lightest);
        border-radius: 8px;
    }

    .luck-category {
        text-align: center;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        font-size: var(--font-size-banner);
        font-weight: var(--font-weight-bold);
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--color-white);
    }

    .low-roll {
        background: var(--color-low-roll);
    }

    .expected {
        background: var(--color-expected);
    }

    .high-roll {
        background: var(--color-high-roll);
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 20px 0;
    }

    .stat-card {
        background: var(--color-white);
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        box-shadow: var(--shadow-subtle);
    }

    .stat-value {
        font-size: var(--font-size-large);
        font-weight: var(--font-weight-bold);
        color: var(--color-dark);
    }

    .stat-label {
        color: var(--color-mid);
        font-size: var(--font-size-label);
        font-weight: var(--font-weight-normal);
        text-transform: uppercase;
        margin-top: 5px;
    }

    .explanation {
        background: var(--color-lightest);
        border: 1px solid var(--color-light);
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
    }

    .explanation h3 {
        color: var(--color-dark);
        font-weight: var(--font-weight-semibold);
        margin-top: 0;
    }
    
    .explanation p {
        font-size: var(--font-size-body);
        font-weight: var(--font-weight-normal);
        color: var(--color-mid-dark);
        line-height: 1.5;
    }
  </style>
</head>
<body>
<div class="app-container">
  <div id="topbar">
    <div id="total">Total: 0</div>
    <div id="topbar-buttons">
      <button id="undo">Undo</button>
      <button id="reset">Reset</button>
    </div>
  </div>

  <div id="stats-bar">
    <div class="stat-item">
      <span id="vpip-display">VPIP: 0% (0/0)</span>
    </div>
    <div id="play-style-indicator">Tight</div>
  </div>

  <div id="view-tabs">
    <button id="grid-tab" class="view-tab active">Grid</button>
    <button id="list-tab" class="view-tab">List</button>
  </div>

  <div id="grid-container">
    <div id="grid" aria-label="13 by 13 poker starting-hand grid"></div>
    
    <div id="toggle-controls">
      <button id="toggleCounts">Counts</button>
      <button id="toggleStrength">Strength</button>
      <button id="toggleHeatmap">Heatmap</button>
      <button id="togglePlayedOnly">Played Only</button>
    </div>
    
    <div class="note">Quick tap: dealt (folded). Long press (>600ms): dealt AND played. <br> Strength is percentile rank (lower = better). <a href="https://www.reddit.com/r/poker/comments/ig8nvw/poker_hand_rankings_chart/">Hand rankings reference</a></div>
  </div>
  
  <div id="list-container">
    <!-- List items will be dynamically generated -->
  </div>
  
  <div id="analysis-results"></div>
  
  <div id="magnify-overlay"></div>
</div>

  <script>
    // ---- Config ----
    const RANKS = ['A','K','Q','J','T','9','8','7','6','5','4','3','2']; // descending
    const handStrengths = {
      // Pocket Pairs
      'AA': 0, 'KK': 1, 'QQ': 1, 'JJ': 2, 'TT': 4,'99': 7, '88': 9, '77': 12, '66': 16, '55': 20, '44': 23, '33': 23, '22': 24,

      // Suited
      'AKs': 2,  'AQs': 2,  'AJs': 3,  'ATs': 5,  'A9s': 8,  'A8s': 10, 'A7s': 13, 'A6s': 14, 'A5s': 12, 'A4s': 14, 'A3s': 14, 'A2s': 17, 
      'KQs': 3,  'KJs': 3,  'KTs': 6,  'K9s': 10, 'K8s': 16, 'K7s': 19, 'K6s': 24, 'K5s': 25, 'K4s': 25, 'K3s': 26, 'K2s': 26, 
      'QJs': 5,  'QTs': 6,  'Q9s': 10, 'Q8s': 19, 'Q7s': 26, 'Q6s': 28, 'Q5s': 29, 'Q4s': 29, 'Q3s': 30, 'Q2s': 31, 
      'JTs': 6,  'J9s': 11, 'J8s': 17, 'J7s': 27, 'J6s': 33, 'J5s': 35, 'J4s': 37, 'J3s': 37, 'J2s': 38, 
      'T9s': 10, 'T8s': 16, 'T7s': 25, 'T6s': 31, 'T5s': 40, 'T4s': 40, 'T3s': 41, 'T2s': 41,
      '98s': 17, '97s': 24, '96s': 29, '95s': 38, '94s': 47, '93s': 47, '92s': 49, 
      '87s': 21, '86s': 27, '85s': 33, '84s': 40, '83s': 53, '82s': 54, 
      '76s': 25, '75s': 28, '74s': 37, '73s': 45, '72s': 56, 
      '65s': 27, '64s': 29, '63s': 38, '62s': 49, 
      '54s': 28, '53s': 32, '52s': 39,
      '43s': 36, '42s': 41, 
      '32s': 46,

      // Offsuit
      'AKo': 5,  'AQo': 8,  'AJo': 12, 'ATo': 18, 'A9o': 32, 'A8o': 39, 'A7o': 45, 'A6o': 51, 'A5o': 44, 'A4o': 46, 'A3o': 49, 'A2o': 54, 
      'KQo': 9,  'KJo': 14, 'KTo': 20, 'K9o': 35, 'K8o': 50, 'K7o': 57, 'K6o': 60, 'K5o': 63, 'K4o': 67, 'K3o': 67, 'K2o': 69, 
      'QJo': 15, 'QTo': 22, 'Q9o': 36, 'Q8o': 53, 'Q7o': 66, 'Q6o': 71, 'Q5o': 75, 'Q4o': 76, 'Q3o': 77, 'Q2o': 79, 
      'JTo': 21, 'J9o': 34, 'J8o': 48, 'J7o': 64, 'J6o': 80, 'J5o': 82, 'J4o': 82, 'J3o': 86, 'J2o': 87, 
      'T9o': 31, 'T8o': 43, 'T7o': 59, 'T6o': 74, 'T5o': 89, 'T4o': 90, 'T3o': 92, 'T2o': 94, 
      '98o': 42, '97o': 55, '96o': 68, '95o': 83, '94o': 95, '93o': 96, '92o': 97, 
      '87o': 52, '86o': 61, '85o': 73, '84o': 88, '83o': 98, '82o': 99, 
      '76o': 57, '75o': 65, '74o': 78, '73o': 93, '72o': 100, 
      '65o': 58, '64o': 70, '63o': 81, '62o': 95,
      '54o': 62, '53o': 72, '52o': 84, 
      '43o': 76, '42o': 86, 
      '32o': 91
    };
    let expectedMean = 0;
    let expectedStdDev = 0;

    // ---- Enhanced State ----
    let hands = []; // Array of hand objects with detailed tracking
    let counts = {}; // key -> integer (total dealt count)
    let playedCounts = {}; // key -> integer (played count)
    let total = 0;
    let totalPlayed = 0;
    let vpip = 0;
    let currentView = 'grid'; // 'grid' or 'list'
    let showCounts = false;
    let showStrength = false;
    let showHeatmap = false;
    let showPlayedOnly = false;
    let activeCell = null;
    let isMouseDown = false;
    let longPressTimer = null;

    // ---- Elements ----
    const grid = document.getElementById('grid');
    const totalEl = document.getElementById('total');
    const resetBtn = document.getElementById('reset');
    const undoBtn = document.getElementById('undo');
    const toggleBtn = document.getElementById('toggleCounts');
    const toggleStrengthBtn = document.getElementById('toggleStrength');
    const toggleHeatmapBtn = document.getElementById('toggleHeatmap');
    const togglePlayedOnlyBtn = document.getElementById('togglePlayedOnly');
    const analysisResultsEl = document.getElementById('analysis-results');
    const appContainer = document.querySelector('.app-container');
    
    // New elements
    const gridTab = document.getElementById('grid-tab');
    const listTab = document.getElementById('list-tab');
    const gridContainer = document.getElementById('grid-container');
    const listContainer = document.getElementById('list-container');
    const vpipDisplay = document.getElementById('vpip-display');
    const playStyleIndicator = document.getElementById('play-style-indicator');
    
    // Magnify overlay
    const magnifyOverlay = document.getElementById('magnify-overlay');

    function calculateExpectedValues() {
        let weightedSum = 0;
        let totalCombinations = 0;
        for (const hand in handStrengths) {
            const strength = handStrengths[hand];
            let combinations;
            if (hand.length === 2) { // Pair
                combinations = 6;
            } else if (hand.endsWith('s')) { // Suited
                combinations = 4;
            } else { // Off-suit
                combinations = 12;
            }
            weightedSum += strength * combinations;
            totalCombinations += combinations;
        }
        expectedMean = weightedSum / totalCombinations;

        let weightedVarianceSum = 0;
        for (const hand in handStrengths) {
            const strength = handStrengths[hand];
            let combinations;
            if (hand.length === 2) { // Pair
                combinations = 6;
            } else if (hand.endsWith('s')) { // Suited
                combinations = 4;
            } else { // Off-suit
                combinations = 12;
            }
            weightedVarianceSum += combinations * Math.pow(strength - expectedMean, 2);
        }
        const expectedVariance = weightedVarianceSum / totalCombinations;
        expectedStdDev = Math.sqrt(expectedVariance);
    }

    // Compose the canonical key for a grid position
    function keyFor(i, j) {
      if (i === j) return RANKS[i] + RANKS[i]; // pair
      const r1 = RANKS[Math.min(i, j)];
      const r2 = RANKS[Math.max(i, j)];
      const suited = i < j;
      return r1 + r2 + (suited ? 's' : 'o');
    }

    function buildGrid() {
      grid.innerHTML = '';
      for (let i = 0; i < 13; i++) {
        for (let j = 0; j < 13; j++) {
          const key = keyFor(i, j);
          counts[key] = counts[key] || 0;
          const cell = document.createElement('button');
          cell.type = 'button';
          cell.className = 'cell' + (i === j ? ' pair' : '');
          cell.dataset.key = key;
          grid.appendChild(cell);
        }
      }
      render();
      fitGridToViewport();
    }
    
    function updateMagnifyOverlay(cell, clientX, clientY) {
      // Store current background color to preserve long press state
      const currentBg = magnifyOverlay.style.backgroundColor;
      
      // Copy cell content and styling to overlay
      magnifyOverlay.textContent = cell.textContent;
      
      // Build classes carefully to avoid disrupting display
      const newClasses = ['cell'];
      if (cell.classList.contains('pair')) {
        newClasses.push('pair');
      }
      magnifyOverlay.className = newClasses.join(' ');
      magnifyOverlay.id = 'magnify-overlay'; // Restore ID
      
      // Apply cell colors but preserve long press background if active
      if (currentBg === '#e8f5e8' || currentBg === 'rgb(232, 245, 232)') {
        // Keep the long press green background
        magnifyOverlay.style.backgroundColor = '#e8f5e8';
      } else {
        // Use cell's background color
        magnifyOverlay.style.backgroundColor = cell.style.backgroundColor || '';
      }
      magnifyOverlay.style.color = cell.style.color || '';
      
      // Center overlay over pointer position (mobile only)
      if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
        const scaledSize = cellSize * 2.0; // Account for scale(2.0) on mobile
        magnifyOverlay.style.left = (clientX - scaledSize / 2) + 'px';
        magnifyOverlay.style.top = (clientY - 40) + 'px'; // Account for translateY(-40px)
      }
    }
    
    function showMagnifyOverlay(cell, clientX, clientY) {
      // Only show overlay on mobile devices
      if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
        magnifyOverlay.style.display = 'flex';
        // Reset background color to clear any leftover green from previous interactions
        magnifyOverlay.style.backgroundColor = '';
        updateMagnifyOverlay(cell, clientX, clientY);
      }
    }
    
    function hideMagnifyOverlay() {
      magnifyOverlay.style.display = 'none';
    }

    function increment(key, played = false) {
      const handEntry = {
        key: key,
        timestamp: Date.now(),
        played: played,
        position: hands.length + 1,
        outcome: null,
        pot: null,
        notes: ""
      };
      
      hands.push(handEntry);
      counts[key] = (counts[key] || 0) + 1;
      total += 1;
      
      if (played) {
        playedCounts[key] = (playedCounts[key] || 0) + 1;
        totalPlayed += 1;
      }
      
      updateStats();
      render();
      saveState();
      analyzeLuck();
    }
    
    function updateStats() {
      vpip = hands.length > 0 ? (totalPlayed / total * 100) : 0;
      
      // Update display
      vpipDisplay.textContent = `VPIP: ${vpip.toFixed(1)}% (${totalPlayed}/${total})`;
      
      // Update play style indicator
      playStyleIndicator.classList.remove('normal', 'loose');
      if (vpip < 20) {
        playStyleIndicator.textContent = 'Tight';
        playStyleIndicator.className = 'tight';
      } else if (vpip <= 30) {
        playStyleIndicator.textContent = 'Normal';
        playStyleIndicator.classList.add('normal');
      } else {
        playStyleIndicator.textContent = 'Loose';
        playStyleIndicator.classList.add('loose');
      }
    }

    function undo() {
      if (hands.length === 0) return;
      
      const lastHand = hands.pop();
      const key = lastHand.key;
      
      if (counts[key] > 0) {
        counts[key] -= 1;
        total -= 1;
      }
      
      if (lastHand.played && playedCounts[key] > 0) {
        playedCounts[key] -= 1;
        totalPlayed -= 1;
      }
      
      updateStats();
      render();
      // Update list view if it's currently active
      if (currentView === 'list') {
        renderList();
      }
      saveState();
      analyzeLuck();
    }

    function resetAll() {
      if (!confirm('Reset all data? This cannot be undone.')) return;
      
      hands.length = 0;
      for (const k in counts) counts[k] = 0;
      for (const k in playedCounts) playedCounts[k] = 0;
      total = 0;
      totalPlayed = 0;
      vpip = 0;
      pfr = 0;
      
      updateStats();
      render();
      renderList();
      saveState();
      analyzeLuck();
    }

    function toggleCounts() {
      showCounts = !showCounts;
      if (showCounts) showStrength = false;
      render();
      saveState();
    }

    function toggleStrength() {
      showStrength = !showStrength;
      if (showStrength) showCounts = false;
      render();
      saveState();
    }

    function toggleHeatmap() {
      showHeatmap = !showHeatmap;
      render();
      saveState();
    }
    
    function togglePlayedOnly() {
      showPlayedOnly = !showPlayedOnly;
      
      // Update button appearance
      if (showPlayedOnly) {
        togglePlayedOnlyBtn.classList.add('toggle-active');
      } else {
        togglePlayedOnlyBtn.classList.remove('toggle-active');
      }
      
      render();
      saveState();
    }
    
    function switchView(view) {
      currentView = view;
      
      if (view === 'grid') {
        gridContainer.style.display = 'flex';
        listContainer.classList.remove('active');
        gridTab.classList.add('active');
        listTab.classList.remove('active');
      } else {
        gridContainer.style.display = 'none';
        listContainer.classList.add('active');
        gridTab.classList.remove('active');
        listTab.classList.add('active');
        renderList();
      }
      
      saveState();
    }

    function saveState() {
      const state = {
        hands,
        counts,
        playedCounts,
        total,
        totalPlayed,
        vpip,
        currentView,
        showCounts,
        showStrength,
        showHeatmap,
        showPlayedOnly
      };
      localStorage.setItem('pokerClickerState', JSON.stringify(state));
    }

    function loadState() {
      const savedState = localStorage.getItem('pokerClickerState');
      if (savedState) {
        const state = JSON.parse(savedState);
        hands = state.hands || [];
        counts = state.counts || {};
        playedCounts = state.playedCounts || {};
        total = state.total || 0;
        totalPlayed = state.totalPlayed || 0;
        vpip = state.vpip || 0;
        currentView = state.currentView || 'grid';
        showCounts = state.showCounts || false;
        showStrength = state.showStrength || false;
        showHeatmap = state.showHeatmap || false;
        showPlayedOnly = state.showPlayedOnly || false;
        
        // Legacy support for old history format
        if (state.history && !state.hands) {
          for (let i = 0; i < state.history.length; i++) {
            hands.push({
              key: state.history[i],
              timestamp: Date.now() - (state.history.length - i) * 1000,
              played: false,
              position: i + 1,
              outcome: null,
              pot: null,
              notes: ""
            });
          }
        }
      }
    }

    function updateCellColors() {
      const cells = grid.children;

      if (showHeatmap) {
        // Strength Heatmap: 3-point gradient
        const strongColor = { r: 16, g: 185, b: 129 };   // high-roll green
        const midColor = { r: 59, g: 130, b: 246 };      // expected blue
        const weakColor = { r: 245, g: 158, b: 11 };     // low-roll orange

        for (const cell of cells) {
            const key = cell.dataset.key;
            const strength = handStrengths[key];
            let r, g, b;

            if (strength <= 50) {
                // 0-50: Interpolate between strongColor (green) and midColor (blue)
                const ratio = strength / 50;
                r = Math.round(strongColor.r + ratio * (midColor.r - strongColor.r));
                g = Math.round(strongColor.g + ratio * (midColor.g - strongColor.g));
                b = Math.round(strongColor.b + ratio * (midColor.b - strongColor.b));
            } else {
                // 50-100: Interpolate between midColor (blue) and weakColor (orange)
                const ratio = (strength - 50) / 50;
                r = Math.round(midColor.r + ratio * (weakColor.r - midColor.r));
                g = Math.round(midColor.g + ratio * (weakColor.g - midColor.g));
                b = Math.round(midColor.b + ratio * (weakColor.b - midColor.b));
            }
            
            cell.style.backgroundColor = `rgb(${r},${g},${b})`;

            const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            cell.style.color = luminance < 128 ? '#ffffff' : '#2d3748';
        }
      } else {
        // Frequency Heatmap - choose between total counts or played counts based on showPlayedOnly
        const sourceData = showPlayedOnly ? playedCounts : counts;
        const values = Object.values(sourceData);
        const max = Math.max(1, ...values);
        
        for (const cell of cells) {
            const key = cell.dataset.key;
            const c = sourceData[key] || 0;

            let baseColor;
            if (key.endsWith('s')) { // Suited
              baseColor = '#D8D8D8';
            } else if (key.length === 2) { // Pair
              baseColor = '#A9A9A9';
            } else { // Off-suit
              baseColor = '#FFFFFF';
            }

            if (c > 0) {
              const ratio = c / max; // 0..1
              const r = 255;
              const g = Math.round(255 * (1 - ratio));
              const b = Math.round(255 * (1 - ratio));
              cell.style.backgroundColor = `rgb(${r},${g},${b})`;
              const luminance = 0.2126*r + 0.7152*g + 0.0722*b;
              cell.style.color = luminance < 128 ? '#ffffff' : '#2d3748';
            } else {
              cell.style.backgroundColor = baseColor;
              cell.style.color = '#2d3748';
            }
        }
      }
    }

    function render() {
      totalEl.textContent = 'Total: ' + total;
      
      for (const cell of grid.children) {
        const key = cell.dataset.key;
        const playedCount = playedCounts[key] || 0;
        const totalCount = counts[key] || 0;
        
        // Update cell content based on showPlayedOnly mode
        if (showCounts) {
          // Show played counts when Played Only is active, otherwise show total counts
          cell.textContent = showPlayedOnly ? playedCount : totalCount;
        } else if (showStrength) {
          cell.textContent = handStrengths[key];
        } else {
          cell.textContent = key;
        }
        
        // Update played indicator (always show when there are played hands)
        cell.classList.toggle('played', playedCount > 0);
        
        // Show all cells - don't hide any when Played Only is active
        cell.style.display = 'flex';
      }
      
      updateCellColors();
    }

    function handleInteractionStart(e) {
      if (e.target.classList.contains('cell')) {
        isMouseDown = true;
        if (activeCell) {
          activeCell.classList.remove('active', 'playing');
        }
        activeCell = e.target;
        activeCell.classList.add('active');
        
        // Show magnify overlay
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        showMagnifyOverlay(activeCell, clientX, clientY);
        
        // Start long press timer (600ms = more than half a second)
        longPressTimer = setTimeout(() => {
          if (isMouseDown && activeCell) {
            activeCell.classList.add('playing');
            // Update overlay background directly via style - no class changes
            magnifyOverlay.style.backgroundColor = '#e8f5e8';
            // Haptic feedback on mobile
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
          }
        }, 600);
        
        e.preventDefault();
      }
    }

    function handleInteractionMove(e) {
      if (isMouseDown) {
        let clientX, clientY;
        if (e.touches) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }
        
        // Update overlay position immediately - centered over pointer (mobile only)
        if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
          const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
          const scaledSize = cellSize * 2.0; // Account for scale(2.0) on mobile
          magnifyOverlay.style.left = (clientX - scaledSize / 2) + 'px';
          magnifyOverlay.style.top = (clientY - 40) + 'px'; // Account for translateY(-40px)
        }
        
        // Use native browser hover detection
        const target = document.elementFromPoint(clientX, clientY);

        if (target && target.classList.contains('cell') && target !== activeCell) {
          // Clear long press timer when moving to different cell
          clearTimeout(longPressTimer);
          
          if (activeCell) {
            activeCell.classList.remove('active', 'playing');
          }
          // Reset overlay background when switching cells
          magnifyOverlay.style.backgroundColor = '';
          
          activeCell = target;
          activeCell.classList.add('active');
          
          // Update overlay content for new cell
          updateMagnifyOverlay(activeCell, clientX, clientY);
          
          // Restart long press timer for new cell (600ms = more than half a second)
          longPressTimer = setTimeout(() => {
            if (isMouseDown && activeCell) {
              activeCell.classList.add('playing');
              // Update overlay background directly via style - no class changes
              magnifyOverlay.style.backgroundColor = '#e8f5e8';
              if (navigator.vibrate) {
                navigator.vibrate(50);
              }
            }
          }, 600);
        }
        e.preventDefault();
      }
    }

    function handleInteractionEnd(e) {
      if (isMouseDown && activeCell) {
        // Check if the release happened over a cell
        let releaseTarget;
        if (e.touches && e.changedTouches && e.changedTouches.length > 0) {
          // Touch event - use the touch point to find the element
          releaseTarget = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        } else {
          // Mouse event
          releaseTarget = e.target;
        }
        
        // Check if we're releasing over the grid container or any cell within it
        const gridContainer = document.getElementById('grid');
        const isOverGrid = releaseTarget && (releaseTarget.classList.contains('cell') || gridContainer.contains(releaseTarget));
        
        if (isOverGrid) {
          // Released over the grid - process the interaction
          const key = activeCell.dataset.key;
          const wasLongPress = activeCell.classList.contains('playing');
          
          clearTimeout(longPressTimer);
          increment(key, wasLongPress);
        } else {
          // Released outside the grid - just clear without incrementing
          clearTimeout(longPressTimer);
        }
        
        activeCell.classList.remove('active', 'playing');
        activeCell = null;
      }
      
      // Hide overlay
      hideMagnifyOverlay();
      
      isMouseDown = false;
      clearTimeout(longPressTimer);
    }

    function renderList() {
      listContainer.innerHTML = '';
      
      // Reverse chronological order (newest first)
      const sortedHands = [...hands].reverse();
      
      sortedHands.forEach((hand, index) => {
        const listItem = document.createElement('div');
        listItem.className = 'list-item';
        listItem.dataset.handIndex = hands.length - 1 - index; // Original index
        
        listItem.innerHTML = `
          <div class="list-item-hand">${hand.key}</div>
          <div class="list-item-position">#${hand.position}</div>
          <div class="list-item-actions">
            <button class="action-button ${hand.played ? 'played' : 'folded'}" data-action="toggle">
              ${hand.played ? 'Played' : 'Folded'}
            </button>
            <button class="delete-button" data-action="delete">
              🗑️
            </button>
          </div>
        `;
        
        // Action button handlers
        const toggleButton = listItem.querySelector('[data-action="toggle"]');
        const deleteButton = listItem.querySelector('[data-action="delete"]');
        
        toggleButton.addEventListener('click', () => {
          toggleHandStatus(parseInt(listItem.dataset.handIndex));
        });
        
        deleteButton.addEventListener('click', () => {
          deleteHand(parseInt(listItem.dataset.handIndex));
        });
        
        listContainer.appendChild(listItem);
      });
    }
    
    function toggleHandStatus(handIndex) {
      const hand = hands[handIndex];
      if (!hand) return;
      
      hand.played = !hand.played;
      
      if (hand.played) {
        playedCounts[hand.key] = (playedCounts[hand.key] || 0) + 1;
        totalPlayed += 1;
      } else {
        playedCounts[hand.key] = Math.max(0, (playedCounts[hand.key] || 0) - 1);
        totalPlayed = Math.max(0, totalPlayed - 1);
      }
      
      updateStats();
      render();
      renderList();
      saveState();
    }
    
    function deleteHand(handIndex) {
      const hand = hands[handIndex];
      if (!hand) return;
      
      // Update counts
      counts[hand.key] = Math.max(0, (counts[hand.key] || 0) - 1);
      total = Math.max(0, total - 1);
      
      if (hand.played) {
        playedCounts[hand.key] = Math.max(0, (playedCounts[hand.key] || 0) - 1);
        totalPlayed = Math.max(0, totalPlayed - 1);
      }
      
      // Remove from hands array
      hands.splice(handIndex, 1);
      
      // Update position numbers for remaining hands
      hands.forEach((h, i) => {
        h.position = i + 1;
      });
      
      updateStats();
      render();
      renderList();
      saveState();
      analyzeLuck();
    }

    function analyzeLuck() {
        if (hands.length === 0) {
            analysisResultsEl.innerHTML = '';
            return;
        }

        const strengths = hands.map(hand => handStrengths[hand.key]);
        const mean = strengths.reduce((a, b) => a + b, 0) / strengths.length;
        const zScore = (mean - expectedMean) / (expectedStdDev / Math.sqrt(strengths.length));

        let category, categoryClass, interpretation;
        if (zScore < -1.5) {
            category = "High Roll 🚀";
            categoryClass = "high-roll";
            interpretation = "You're getting significantly better than expected hands!";
        } else if (zScore > 1.5) {
            category = "Low Roll 😩";
            categoryClass = "low-roll";
            interpretation = "You're experiencing significantly worse than expected luck with your dealt hands.";
        } else {
            category = "Expected 📊";
            categoryClass = "expected";
            interpretation = "Your dealt hands are within normal expected variance.";
        }

        analysisResultsEl.innerHTML = `
            <div class="results">
                <div class="luck-category ${categoryClass}">${category}</div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${mean.toFixed(1)}</div>
                        <div class="stat-label">Average Strength</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${zScore.toFixed(2)}</div>
                        <div class="stat-label">Z-Score</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${(expectedStdDev * Math.sqrt(strengths.length)).toFixed(1)}</div>
                        <div class="stat-label">Std Deviation</div>
                    </div>
                </div>
                
                <div class="explanation">
                    <h3>📈 Statistical Analysis</h3>
                    <p><strong>Interpretation:</strong> ${interpretation}</p>
                    <p><strong>Z-Score Explained:</strong> ${Math.abs(zScore).toFixed(2)} standard deviations ${zScore >= 0 ? 'above' : 'below'} expected. Values beyond ±1.5 are considered significantly different from normal.</p>
                    <p><strong>Your Average:</strong> ${mean.toFixed(1)} vs Expected: ${expectedMean.toFixed(1)} (scale: 0-100)</p>
                </div>
            </div>
        `;
    }

    // ---- Responsive sizing ----
    function fitGridToViewport() {
      const root = document.documentElement;
      const vw = document.documentElement.clientWidth;
      
      // Responsive gap based on breakpoints
      let chosenGap;
      if (vw < 480) chosenGap = 2; // phone
      else if (vw < 768) chosenGap = 3; // tablet
      else chosenGap = 4; // desktop
      
      root.style.setProperty('--gap', chosenGap + 'px');

      // Calculate available width based on viewport size
      let containerPadding, bodyPadding;
      if (vw < 480) {
        // Mobile: no body padding, minimal container padding
        containerPadding = 24; // 12px * 2
        bodyPadding = 0;
      } else {
        // Desktop/tablet: normal padding
        containerPadding = 40; // 20px * 2
        bodyPadding = 40; // 20px * 2
      }
      
      const gridWidth = vw - containerPadding - bodyPadding;

      const MAX_CELL = vw < 480 ? 80 : 56; // Allow larger cells on mobile
      const MIN_CELL = 18;

      // Dynamic calculation: (viewport - padding - gaps) / 13
      const ideal = Math.floor((gridWidth - chosenGap * 12) / 13);
      const cell = Math.max(MIN_CELL, Math.min(MAX_CELL, ideal));
      root.style.setProperty('--cell', cell + 'px');

      // Border radius: cell-size / 10, minimum 2px
      const radius = Math.max(2, Math.round(cell / 10));
      root.style.setProperty('--radius', radius + 'px');
    }

    resetBtn.addEventListener('click', resetAll);
    undoBtn.addEventListener('click', undo);
    toggleBtn.addEventListener('click', toggleCounts);
    toggleStrengthBtn.addEventListener('click', toggleStrength);
    toggleHeatmapBtn.addEventListener('click', toggleHeatmap);
    togglePlayedOnlyBtn.addEventListener('click', togglePlayedOnly);
    
    // View tab handlers
    gridTab.addEventListener('click', () => switchView('grid'));
    listTab.addEventListener('click', () => switchView('list'));
    
    // Use throttled resize for better performance
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(fitGridToViewport, 100);
    }, { passive: true });
    window.addEventListener('orientationchange', () => {
      setTimeout(fitGridToViewport, 200); // Delay for orientation change
    });

    grid.addEventListener('mousedown', handleInteractionStart);
    grid.addEventListener('mousemove', handleInteractionMove);
    document.addEventListener('mouseup', handleInteractionEnd); // Listen on document to catch mouseup outside grid

    grid.addEventListener('touchstart', handleInteractionStart, { passive: false });
    grid.addEventListener('touchmove', handleInteractionMove, { passive: false });
    grid.addEventListener('touchend', handleInteractionEnd);

    // Initialize
    calculateExpectedValues();
    loadState();
    buildGrid();
    updateStats();
    switchView(currentView);
    
    // Set initial toggle button states
    if (showPlayedOnly) {
      togglePlayedOnlyBtn.classList.add('toggle-active');
    }
    
    analyzeLuck();
  </script>
</body>
</html>