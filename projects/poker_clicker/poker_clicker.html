<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Poker Multi-Session Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { 
      --cell: 54px; --gap: 4px; --radius: 8px;
      /* Color Palette */
      --color-dark: #2d3748;
      --color-mid-dark: #4a5568;
      --color-mid: #718096;
      --color-light: #e2e8f0;
      --color-lighter: #edf2f7;
      --color-lightest: #f7fafc;
      --color-white: #ffffff;
      /* Semantic Colors */
      --color-high-roll: linear-gradient(135deg, #10b981, #059669);
      --color-expected: linear-gradient(135deg, #3b82f6, #2563eb);
      --color-low-roll: linear-gradient(135deg, #f59e0b, #d97706);
      /* Typography */
      --font-size-banner: 24px;
      --font-size-large: 20px;
      --font-size-body: 14px;
      --font-size-label: 12px;
      --font-size-cell: 11px;
      --font-weight-bold: 700;
      --font-weight-semibold: 600;
      --font-weight-medium: 500;
      --font-weight-normal: 400;
      /* Shadows */
      --shadow-hero: 0 20px 60px rgba(0,0,0,0.3);
      --shadow-elevated: 0 4px 12px rgba(0,0,0,0.3);
      --shadow-subtle: 0 2px 8px rgba(0,0,0,0.1);
      /* Transitions */
      --transition-micro: 0.15s ease;
      --transition-standard: 0.2s ease;
      --transition-smooth: 0.3s ease;
    }
    * { box-sizing: border-box; }
    html, body { min-height: 100%; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      margin: 0; 
      padding: 20px;
      background: var(--color-lightest); 
      color: var(--color-dark); 
      display: flex; 
      justify-content: center; 
      align-items: flex-start;
      -webkit-text-size-adjust: none; 
      text-size-adjust: none; 
    }

    .app-container { 
      width: 100%; 
      max-width: 900px;
      background: var(--color-white);
      border-radius: 12px;
      padding: 20px;
      box-shadow: var(--shadow-hero);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Session Management Section */
    #session-management {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      background: var(--color-lightest);
      border-radius: 8px;
      padding: 16px;
      border: 1px solid var(--color-light);
    }

    .session-title {
      font-size: var(--font-size-large);
      font-weight: var(--font-weight-semibold);
      color: var(--color-dark);
    }

    .session-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    #session-selector {
      padding: 8px 12px;
      border: 1px solid var(--color-light);
      border-radius: 6px;
      background: var(--color-white);
      color: var(--color-dark);
      font-size: var(--font-size-body);
      cursor: pointer;
      flex: 1;
      min-width: 150px;
    }

    #session-selector option.new-session {
      font-weight: var(--font-weight-semibold);
      color: var(--color-mid-dark);
    }

    .session-button {
      padding: 8px 12px;
      border: 1px solid var(--color-light);
      border-radius: 6px;
      background: var(--color-white);
      color: var(--color-dark);
      font-size: var(--font-size-body);
      cursor: pointer;
      transition: var(--transition-standard);
      white-space: nowrap;
    }

    .session-button:hover {
      background: var(--color-lighter);
      transform: translateY(-1px);
    }

    .session-button.danger {
      background: #ef4444;
      color: var(--color-white);
      border-color: #ef4444;
    }

    .session-button.danger:hover {
      background: #dc2626;
      border-color: #dc2626;
    }

    /* Modal for session creation */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--color-white);
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 400px;
      box-shadow: var(--shadow-hero);
    }

    .modal h3 {
      margin: 0 0 16px 0;
      color: var(--color-dark);
      font-weight: var(--font-weight-semibold);
    }

    .modal input {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--color-light);
      border-radius: 6px;
      font-size: var(--font-size-body);
      margin-bottom: 16px;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .modal button {
      padding: 10px 16px;
      border: 1px solid var(--color-light);
      border-radius: 6px;
      background: var(--color-white);
      color: var(--color-dark);
      cursor: pointer;
      transition: var(--transition-standard);
    }

    .modal button.primary {
      background: var(--color-mid-dark);
      color: var(--color-white);
      border-color: var(--color-mid-dark);
    }

    .modal button:hover {
      background: var(--color-lighter);
    }

    .modal button.primary:hover {
      background: var(--color-dark);
      border-color: var(--color-dark);
    }

    #topbar { 
      position: sticky; 
      top: 0; 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      padding: 12px 16px;
      background: var(--color-white);
      border-radius: 8px;
      box-shadow: var(--shadow-subtle);
      z-index: 10; 
    }
    #topbar-buttons { display: flex; gap: 12px; }
    
    #stats-bar {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: rgba(74, 85, 104, 0.9);
      backdrop-filter: blur(8px);
      border-radius: 8px;
      z-index: 9;
      margin-top: -8px;
      gap: 16px;
    }
    
    .stat-item {
      color: var(--color-white);
      font-size: 16px;
      font-weight: var(--font-weight-semibold);
    }
    
    .profit-loss-display {
      text-align: center;
      flex: 1;
    }
    
    #profit-loss-amount {
      font-size: 20px;
      font-weight: var(--font-weight-bold);
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }
    
    #profit-loss-amount.positive {
      color: #10b981;
    }
    
    #profit-loss-amount.negative {
      color: #ff5555;
    }
    
    #profit-loss-amount.neutral {
      color: var(--color-white);
    }
    
    #play-style-indicator {
      font-size: 14px;
      font-weight: var(--font-weight-medium);
      padding: 6px 12px;
      border-radius: 12px;
      transition: var(--transition-standard);
    }
    
    #play-style-indicator.nit {
      background: #EFD30B;
    }

    #play-style-indicator.tight {
      background: #3b82f6;
    }
    
    #play-style-indicator.normal {
      background: #10b981;
    }
    
    #play-style-indicator.loose {
      background: #f59e0b;
    }
    
    #play-style-indicator.maniac {
      background: #ef4444;
    }
    
    #view-tabs {
      display: flex;
      gap: 4px;
      background: var(--color-lighter);
      border-radius: 8px;
      padding: 4px;
    }
    
    .view-tab {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: var(--color-mid);
      font-weight: var(--font-weight-medium);
      transition: var(--transition-standard);
      cursor: pointer;
    }
    
    .view-tab.active {
      background: var(--color-white);
      color: var(--color-dark);
      box-shadow: var(--shadow-subtle);
    }
    
    .view-tab:hover:not(.active) {
      background: rgba(255, 255, 255, 0.5);
    }
    #total { 
      font-weight: var(--font-weight-semibold); 
      font-size: var(--font-size-large); 
      padding: 12px 16px; 
      background: var(--color-lightest); 
      border: 1px solid var(--color-light); 
      border-radius: 20px; 
      color: var(--color-dark);
    }
    button { 
      padding: 10px 14px; 
      border: 1px solid var(--color-light); 
      border-radius: 6px; 
      background: var(--color-white); 
      color: var(--color-dark);
      font-weight: var(--font-weight-medium);
      font-size: var(--font-size-body);
      cursor: pointer; 
      transition: var(--transition-standard);
      -webkit-tap-highlight-color: transparent; 
      touch-action: manipulation; 
    }
    button:hover {
      transform: translateY(-1px);
      background: var(--color-lighter);
    }
    button:active { 
      transform: translateY(0); 
    }
    
    button.toggle-active {
      background: var(--color-mid-dark) !important;
      color: var(--color-white) !important;
      border-color: var(--color-mid-dark) !important;
    }
    
    button.toggle-active:hover {
      background: var(--color-dark) !important;
      border-color: var(--color-dark) !important;
    }

    #grid-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }
    
    #list-container {
      display: none;
      flex-direction: column;
      gap: 12px;
      max-height: 60vh;
      overflow-y: auto;
    }
    
    #list-container.active {
      display: flex;
    }
    
    #details-container {
      display: none;
      flex-direction: column;
      gap: 20px;
    }
    
    #details-container.active {
      display: flex;
    }
    
    .details-section {
      background: var(--color-lightest);
      border-radius: 8px;
      padding: 20px;
      border: 1px solid var(--color-light);
    }
    
    .details-title {
      margin: 0 0 20px 0;
      font-size: var(--font-size-large);
      font-weight: var(--font-weight-semibold);
      color: var(--color-dark);
    }
    
    .details-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
    }
    
    .detail-field {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .detail-field-full {
      grid-column: 1 / -1;
    }
    
    .detail-field label {
      font-size: var(--font-size-body);
      font-weight: var(--font-weight-medium);
      color: var(--color-dark);
    }
    
    .detail-field input,
    .detail-field textarea {
      padding: 12px;
      border: 1px solid var(--color-light);
      border-radius: 6px;
      font-size: var(--font-size-body);
      background: var(--color-white);
      color: var(--color-dark);
      transition: var(--transition-standard);
    }
    
    .detail-field input:focus,
    .detail-field textarea:focus {
      outline: none;
      border-color: var(--color-mid-dark);
      box-shadow: 0 0 0 3px rgba(74, 85, 104, 0.1);
    }
    
    .detail-field textarea {
      resize: vertical;
      font-family: inherit;
    }
    
    @media (max-width: 767px) {
      .details-grid {
        grid-template-columns: 1fr;
      }
      
      .details-section {
        padding: 16px;
      }
    }
    
    /* Aggregate Stats Styles */
    .aggregate-section {
      margin-bottom: 24px;
    }
    
    .aggregate-section:last-child {
      margin-bottom: 0;
    }
    
    .aggregate-section-title {
      font-size: var(--font-size-large);
      font-weight: var(--font-weight-semibold);
      color: var(--color-dark);
      margin: 0 0 16px 0;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--color-light);
    }
    
    .aggregate-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 16px;
    }
    
    .aggregate-stat-card {
      background: var(--color-white);
      border: 1px solid var(--color-light);
      border-radius: 8px;
      padding: 16px;
      text-align: center;
      box-shadow: var(--shadow-subtle);
      transition: var(--transition-standard);
    }
    
    .aggregate-stat-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-elevated);
    }
    
    .aggregate-stat-value {
      font-size: 20px;
      font-weight: var(--font-weight-bold);
      color: var(--color-dark);
      margin-bottom: 4px;
    }
    
    .aggregate-stat-value.positive {
      color: #10b981;
    }
    
    .aggregate-stat-value.negative {
      color: #ef4444;
    }
    
    .aggregate-stat-label {
      font-size: var(--font-size-body);
      color: var(--color-mid);
      font-weight: var(--font-weight-medium);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    @media (max-width: 767px) {
      .aggregate-stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
      
      .aggregate-stat-card {
        padding: 12px;
      }
      
      .aggregate-stat-value {
        font-size: 18px;
      }
      
      .aggregate-section-title {
        font-size: 18px;
      }
    }
    
    /* Bankroll Chart Styles */
    .bankroll-chart-container {
      background: var(--color-white);
      border-radius: 8px;
      padding: 20px;
      border: 1px solid var(--color-light);
      box-shadow: var(--shadow-subtle);
      height: 400px;
      position: relative;
    }
    
    @media (max-width: 767px) {
      .bankroll-chart-container {
        height: 300px;
        padding: 16px;
      }
    }
    
    .list-item {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      padding: 8px 16px;
      background: var(--color-white);
      border: 1px solid var(--color-light);
      border-radius: 8px;
      transition: var(--transition-standard);
      position: relative;
      gap: 12px;
    }
    
    .list-item:nth-child(even) {
      background: var(--color-lightest);
    }
    
    .list-item-hand {
      font-weight: var(--font-weight-semibold);
      font-size: 16px;
      min-width: 60px;
    }
    
    .list-item-position {
      flex: 1;
      text-align: center;
      color: var(--color-mid);
      font-size: 14px;
    }
    
    .list-item-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }
    
    .action-button {
      padding: 6px 12px;
      border: 1px solid var(--color-light);
      border-radius: 4px;
      background: var(--color-white);
      color: var(--color-dark);
      font-size: 12px;
      cursor: pointer;
      transition: var(--transition-micro);
      white-space: nowrap;
    }
    
    .action-button:hover {
      background: var(--color-lighter);
    }
    
    .action-button.played {
      background: #10b981;
      color: white;
      border-color: #10b981;
    }
    
    .action-button.folded {
      background: #9CA3AF;
      color: white;
      border-color: #9CA3AF;
    }
    
    /* Toggle Switch Styles */
    .toggle-switch {
      position: relative;
      width: 60px;
      height: 28px;
      background: #9CA3AF;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s ease;
      display: flex;
      align-items: center;
      padding: 0;
      outline: none;
    }
    
    .toggle-switch:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    .toggle-switch:not(:disabled) {
      opacity: 1;
    }
    
    .toggle-switch.played {
      background: #10b981;
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      left: 2px;
      transition: transform 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .toggle-switch::before {
      content: '✕';
      position: absolute;
      color: white;
      font-size: 12px;
      font-weight: bold;
      z-index: 2;
      left: 40px;
      top: 50%;
      transform: translateY(-50%);
      transition: all 0.2s ease;
    }
    
    .toggle-switch.played::after {
      transform: translateX(32px);
    }
    
    .toggle-switch.played::before {
      content: '▶';
      left: 8px;
      font-size: 12px;
    }
    
    .toggle-switch:hover {
      transform: none;
      background: #9CA3AF;
    }
    
    .toggle-switch.played:hover {
      background: #10b981;
    }
    
    
    .delete-button {
      padding: 6px 8px;
      border: 1px solid #ef4444;
      border-radius: 4px;
      background: #ef4444;
      color: white;
      cursor: pointer;
      transition: var(--transition-micro);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    
    .delete-button:hover {
      background: #dc2626;
      border-color: #dc2626;
    }
    
    .list-item-notes-container {
      display: none;
      flex-basis: 100%;
      padding-top: 8px;
    }

    .list-item-notes-container.active {
      display: block;
    }

    .list-item-notes {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--color-light);
      border-radius: 6px;
      font-size: var(--font-size-body);
      resize: vertical;
      min-height: 60px;
      background-color: var(--color-lightest);
    }
    
    .notes-button.toggle-active {
      background: var(--color-mid-dark) !important;
      color: var(--color-white) !important;
      border-color: var(--color-mid-dark) !important;
    }


    #grid { width: 100%; display: grid; grid-template-columns: repeat(13, var(--cell)); grid-auto-rows: var(--cell); gap: var(--gap); min-width: 0; justify-content: center; }

    .cell { 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      text-align: center; 
      border: 1px solid var(--color-light); 
      border-radius: var(--radius); 
      background: var(--color-white); 
      color: var(--color-dark);
      user-select: none; 
      cursor: pointer; 
      transition: var(--transition-micro); 
      font-size: var(--font-size-cell); 
      font-weight: var(--font-weight-normal);
      padding: 0; 
      line-height: 1.05; 
      min-width: var(--cell); 
      min-height: var(--cell); 
      white-space: nowrap; 
      overflow: hidden; 
    }
    .cell.pair { 
      font-weight: var(--font-weight-semibold); 
    }
    .cell:active { 
      transform: scale(0.98); 
    }
    .cell.active { 
      opacity: 0.3;
    }
    
    /* Overlay only visible on mobile devices */
    @media (hover: none) and (pointer: coarse) {
      #magnify-overlay {
        position: fixed;
        width: var(--cell);
        height: var(--cell);
        display: none;
        align-items: center;
        justify-content: center;
        text-align: center;
        border: 1px solid var(--color-light);
        border-radius: var(--radius);
        background: var(--color-white);
        color: var(--color-dark);
        font-size: var(--font-size-cell);
        font-weight: var(--font-weight-normal);
        line-height: 1.05;
        white-space: nowrap;
        overflow: hidden;
        pointer-events: none;
        z-index: 1000;
        transform: scale(2.0) translateY(-20px);
        transform-origin: center center;
        box-shadow: var(--shadow-elevated);
        transition: none;
        will-change: transform;
      }
    }
    
    /* Hide overlay on desktop */
    @media (hover: hover) and (pointer: fine) {
      #magnify-overlay {
        display: none !important;
      }
    }
    
    
    .cell.played {
      position: relative;
    }
    
    .cell.played::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 2px;
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      border: 1px solid var(--color-white);
    }
    
    @media (max-width: 767px) {
      .cell.played::after {
        width: 5px;
        height: 5px;
        top: 1px;
        right: 1px;
        border-width: 0.5px;
      }
    }
    
    .cell.playing {
      animation: playingPulse 0.3s ease-in-out;
      background: rgba(16, 185, 129, 0.2) !important;
    }
    
    @keyframes playingPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }


    .note { 
      font-size: var(--font-size-label); 
      color: var(--color-mid); 
      font-weight: var(--font-weight-normal);
      text-align: left;
      max-width: 600px;
      line-height: 1.4;
      margin-top: auto;
      padding-top: 16px;
      border-top: 1px solid var(--color-light);
    }
    
    @media (max-width: 767px) {
      .note {
        font-size: 10px;
        line-height: 1.3;
        padding-top: 12px;
        margin-top: 16px;
      }
    }

    #toggle-controls {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    /* Import/Export Styles */
    .import-export-section {
      margin-top: 40px;
      padding: 24px;
      background: var(--color-lightest);
      border-radius: 8px;
      border: 1px solid var(--color-light);
    }

    .import-export-title {
      font-size: var(--font-size-large);
      font-weight: var(--font-weight-semibold);
      color: var(--color-dark);
      margin: 0 0 16px 0;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--color-light);
    }

    .import-export-buttons {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .import-export-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 20px;
      border: 2px solid;
      border-radius: 6px;
      font-size: var(--font-size-body);
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: all 0.2s ease;
      background: var(--color-white);
      min-width: 140px;
      justify-content: center;
    }

    .export-btn {
      border-color: #10b981;
      color: #10b981;
    }

    .export-btn:hover {
      background: #10b981;
      color: var(--color-white);
    }

    .import-btn {
      border-color: #3b82f6;
      color: #3b82f6;
    }

    .import-btn:hover {
      background: #3b82f6;
      color: var(--color-white);
    }

    .btn-icon {
      font-size: 16px;
    }

    .import-export-description {
      font-size: var(--font-size-small);
      color: var(--color-medium);
      line-height: 1.5;
    }

    @media (max-width: 479px) {
      .import-export-section {
        margin-top: 24px;
        padding: 16px;
      }

      .import-export-buttons {
        flex-direction: column;
        gap: 12px;
      }

      .import-export-btn {
        width: 100%;
      }
    }

    /* Responsive Breakpoints */
    @media (max-width: 479px) {
      body { padding: 0; }
      .app-container { 
        padding: 12px; 
        border-radius: 0;
        box-shadow: none;
      }
      #topbar { padding: 8px 12px; }
      
      #session-management {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      
      .session-controls {
        justify-content: space-between;
      }
      
      #session-selector {
        min-width: 120px;
      }
      
      .session-button {
        padding: 6px 10px;
        font-size: 13px;
      }
    }
    
    @media (min-width: 480px) and (max-width: 767px) {
      body { padding: 20px; }
    }
    
    @media (min-width: 768px) {
      body { padding: 24px; }
    }
    
    @media (min-width: 1200px) {
      .app-container { max-width: 900px; }
    }

    .results {
        padding: 20px;
        background: var(--color-lightest);
        border-radius: 8px;
    }

    .luck-category {
        text-align: center;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        font-size: var(--font-size-banner);
        font-weight: var(--font-weight-bold);
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--color-white);
    }

    .low-roll {
        background: var(--color-low-roll);
    }

    .expected {
        background: var(--color-expected);
    }

    .high-roll {
        background: var(--color-high-roll);
    }

    .stats-grid {
        display: flex;
        gap: 8px;
        margin: 15px 0;
        justify-content: center;
        flex-wrap: wrap;
    }

    .stat-card {
        background: var(--color-white);
        padding: 8px 12px;
        border-radius: 6px;
        text-align: center;
        box-shadow: var(--shadow-subtle);
        flex: 0 1 auto;
        min-width: 80px;
    }

    .stat-value {
        font-size: 16px;
        font-weight: var(--font-weight-bold);
        color: var(--color-dark);
        line-height: 1.2;
    }

    .stat-label {
        color: var(--color-mid);
        font-size: 10px;
        font-weight: var(--font-weight-medium);
        text-transform: uppercase;
        margin-top: 2px;
        line-height: 1.1;
    }

    @media (max-width: 480px) {
        .stats-grid {
            gap: 6px;
            margin: 12px 0;
        }
        
        .stat-card {
            padding: 6px 8px;
            min-width: 70px;
        }
        
        .stat-value {
            font-size: 14px;
        }
        
        .stat-label {
            font-size: 9px;
        }
    }

    .explanation {
        background: var(--color-lightest);
        border: 1px solid var(--color-light);
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
    }

    .explanation h3 {
        color: var(--color-dark);
        font-weight: var(--font-weight-semibold);
        margin-top: 0;
    }
    
    .explanation p {
        font-size: var(--font-size-body);
        font-weight: var(--font-weight-normal);
        color: var(--color-mid-dark);
        line-height: 1.5;
    }
    
    .histogram-container {
        background: var(--color-white);
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
        box-shadow: var(--shadow-subtle);
        height: 400px;
        display: flex;
        flex-direction: column;
    }
    
    .histogram-title {
        font-size: var(--font-size-large);
        font-weight: var(--font-weight-semibold);
        color: var(--color-dark);
        margin: 0 0 15px 0;
        text-align: center;
    }
    
    .chart-wrapper {
        flex: 1;
        position: relative;
        min-height: 0;
    }
  </style>
</head>
<body>
<div class="app-container">
  <!-- Session Management Section -->
  <div id="session-management">
    <div class="session-title">Multi-Session Poker Tracker</div>
    <div class="session-controls">
      <select id="session-selector">
        <option value="__new__" class="new-session">+ Create New Session</option>
      </select>
      <button id="rename-session" class="session-button">Rename</button>
      <button id="delete-session" class="session-button danger">Delete</button>
    </div>
  </div>


  <div id="stats-bar">
    <div class="stat-item">
      <span id="vpip-display">Select session to start tracking</span>
    </div>
    <div class="profit-loss-display">
      <span id="profit-loss-amount"></span>
    </div>
    <div id="play-style-indicator">&nbsp</div>
  </div>

  <div id="view-tabs">
    <button id="grid-tab" class="view-tab active">Grid</button>
    <button id="list-tab" class="view-tab">List</button>
    <button id="details-tab" class="view-tab">Details</button>
  </div>

  <div id="grid-container">
    <div id="grid" aria-label="13 by 13 poker starting-hand grid"></div>
    
    <div id="toggle-controls">
      <button id="toggleCounts">Counts</button>
      <button id="toggleStrength">Strength</button>
      <button id="toggleHeatmap">Heatmap</button>
      <button id="togglePlayed">Played</button>
      <button id="undo">Undo</button>
    </div>
    
    <div class="note">Quick tap: dealt (folded). Long press (>600ms): dealt AND played. <br> Strength is percentile rank (lower = better). <a href="https://www.reddit.com/r/poker/comments/ig8nvw/poker_hand_rankings_chart/">Hand rankings reference</a></div>
  </div>
  
  <div id="list-container">
    <!-- List items will be dynamically generated -->
  </div>
  
  <div id="details-container">
    <div class="details-section">
      <h3 class="details-title">Session Details</h3>
      <div class="details-grid">
        <div class="detail-field">
          <label for="buy-in">Buy In ($)</label>
          <input type="number" id="buy-in" placeholder="0.00" step="0.01" min="0">
        </div>
        <div class="detail-field">
          <label for="cash-out">Cash Out ($)</label>
          <input type="number" id="cash-out" placeholder="0.00" step="0.01" min="0">
        </div>
        <div class="detail-field">
          <label for="small-blind">Small Blind ($)</label>
          <input type="number" id="small-blind" placeholder="0.00" step="0.01" min="0">
        </div>
        <div class="detail-field">
          <label for="big-blind">Big Blind ($)</label>
          <input type="number" id="big-blind" placeholder="0.00" step="0.01" min="0">
        </div>
        <div class="detail-field">
          <label for="start-time">Start Time</label>
          <input type="datetime-local" id="start-time">
        </div>
        <div class="detail-field">
          <label for="end-time">End Time</label>
          <input type="datetime-local" id="end-time">
        </div>
        <div class="detail-field detail-field-full">
          <label for="session-notes">Notes</label>
          <textarea id="session-notes" placeholder="Session notes, observations, etc." rows="4"></textarea>
        </div>
      </div>
    </div>
  </div>
  
  <div id="analysis-results"></div>

  <div id="magnify-overlay"></div>

  <!-- Import/Export Section -->
  <div class="import-export-section">
    <h3 class="import-export-title">Data Management</h3>
    <div class="import-export-buttons">
      <button id="export-data" class="import-export-btn export-btn">
        <span class="btn-icon">📥</span>
        Export Data
      </button>
      <button id="import-data" class="import-export-btn import-btn">
        <span class="btn-icon">📤</span>
        Import Data
      </button>
      <input type="file" id="file-input" accept=".json" style="display: none;">
    </div>
    <div class="import-export-description">
      Export your poker session data to a JSON file for backup or transfer to another device. Import previously exported data to restore your sessions.
    </div>
  </div>
</div>

<!-- Session Creation Modal -->
<div id="session-modal" class="modal-overlay">
  <div class="modal">
    <h3 id="modal-title">Create New Session</h3>
    <input type="text" id="session-name-input" placeholder="Enter session name..." />
    <div class="modal-actions">
      <button id="modal-cancel">Cancel</button>
      <button id="modal-confirm" class="primary">Create</button>
    </div>
  </div>
</div>

  <script>
    // ---- Config ----
    const RANKS = ['A','K','Q','J','T','9','8','7','6','5','4','3','2']; // descending
    const handStrengths = {
      // Pocket Pairs
      'AA': 0, 'KK': 1, 'QQ': 1, 'JJ': 2, 'TT': 4,'99': 7, '88': 9, '77': 12, '66': 16, '55': 20, '44': 23, '33': 23, '22': 24,

      // Suited
      'AKs': 2,  'AQs': 2,  'AJs': 3,  'ATs': 5,  'A9s': 8,  'A8s': 10, 'A7s': 13, 'A6s': 14, 'A5s': 12, 'A4s': 14, 'A3s': 14, 'A2s': 17, 
      'KQs': 3,  'KJs': 3,  'KTs': 6,  'K9s': 10, 'K8s': 16, 'K7s': 19, 'K6s': 24, 'K5s': 25, 'K4s': 25, 'K3s': 26, 'K2s': 26, 
      'QJs': 5,  'QTs': 6,  'Q9s': 10, 'Q8s': 19, 'Q7s': 26, 'Q6s': 28, 'Q5s': 29, 'Q4s': 29, 'Q3s': 30, 'Q2s': 31, 
      'JTs': 6,  'J9s': 11, 'J8s': 17, 'J7s': 27, 'J6s': 33, 'J5s': 35, 'J4s': 37, 'J3s': 37, 'J2s': 38, 
      'T9s': 10, 'T8s': 16, 'T7s': 25, 'T6s': 31, 'T5s': 40, 'T4s': 40, 'T3s': 41, 'T2s': 41,
      '98s': 17, '97s': 24, '96s': 29, '95s': 38, '94s': 47, '93s': 47, '92s': 49, 
      '87s': 21, '86s': 27, '85s': 33, '84s': 40, '83s': 53, '82s': 54, 
      '76s': 25, '75s': 28, '74s': 37, '73s': 45, '72s': 56, 
      '65s': 27, '64s': 29, '63s': 38, '62s': 49, 
      '54s': 28, '53s': 32, '52s': 39,
      '43s': 36, '42s': 41, 
      '32s': 46,

      // Offsuit
      'AKo': 5,  'AQo': 8,  'AJo': 12, 'ATo': 18, 'A9o': 32, 'A8o': 39, 'A7o': 45, 'A6o': 51, 'A5o': 44, 'A4o': 46, 'A3o': 49, 'A2o': 54, 
      'KQo': 9,  'KJo': 14, 'KTo': 20, 'K9o': 35, 'K8o': 50, 'K7o': 57, 'K6o': 60, 'K5o': 63, 'K4o': 67, 'K3o': 67, 'K2o': 69, 
      'QJo': 15, 'QTo': 22, 'Q9o': 36, 'Q8o': 53, 'Q7o': 66, 'Q6o': 71, 'Q5o': 75, 'Q4o': 76, 'Q3o': 77, 'Q2o': 79, 
      'JTo': 21, 'J9o': 34, 'J8o': 48, 'J7o': 64, 'J6o': 80, 'J5o': 82, 'J4o': 82, 'J3o': 86, 'J2o': 87, 
      'T9o': 31, 'T8o': 43, 'T7o': 59, 'T6o': 74, 'T5o': 89, 'T4o': 90, 'T3o': 92, 'T2o': 94, 
      '98o': 42, '97o': 55, '96o': 68, '95o': 83, '94o': 95, '93o': 96, '92o': 97, 
      '87o': 52, '86o': 61, '85o': 73, '84o': 88, '83o': 98, '82o': 99, 
      '76o': 57, '75o': 65, '74o': 78, '73o': 93, '72o': 100, 
      '65o': 58, '64o': 70, '63o': 81, '62o': 95,
      '54o': 62, '53o': 72, '52o': 84, 
      '43o': 76, '42o': 86, 
      '32o': 91
    };
    let expectedMean = 0;
    let expectedStdDev = 0;

    // ---- Multi-Session State ----
    let sessions = {}; // sessionId -> session data
    let currentSessionId = null;
    let sessionCounter = 1;
    
    // Current view state (applies to all sessions)
    let currentView = 'grid'; // 'grid' or 'list'
    let showCounts = false;
    let showStrength = false;
    let showHeatmap = false;
    let showPlayed = false;
    
    // Interaction state
    let activeCell = null;
    let isMouseDown = false;
    let longPressTimer = null;

    // ---- Elements ----
    const grid = document.getElementById('grid');
    const undoBtn = document.getElementById('undo');
    const toggleBtn = document.getElementById('toggleCounts');
    const toggleStrengthBtn = document.getElementById('toggleStrength');
    const toggleHeatmapBtn = document.getElementById('toggleHeatmap');
    const togglePlayedBtn = document.getElementById('togglePlayed');
    const analysisResultsEl = document.getElementById('analysis-results');
    
    // View elements
    const gridTab = document.getElementById('grid-tab');
    const listTab = document.getElementById('list-tab');
    const detailsTab = document.getElementById('details-tab');
    const gridContainer = document.getElementById('grid-container');
    const listContainer = document.getElementById('list-container');
    const detailsContainer = document.getElementById('details-container');
    const vpipDisplay = document.getElementById('vpip-display');
    const profitLossAmount = document.getElementById('profit-loss-amount');
    const playStyleIndicator = document.getElementById('play-style-indicator');
    
    // Details form elements
    let buyInInput = document.getElementById('buy-in');
    let cashOutInput = document.getElementById('cash-out');
    let smallBlindInput = document.getElementById('small-blind');
    let bigBlindInput = document.getElementById('big-blind');
    let startTimeInput = document.getElementById('start-time');
    let endTimeInput = document.getElementById('end-time');
    let sessionNotesInput = document.getElementById('session-notes');
    
    // Session management elements
    const sessionSelector = document.getElementById('session-selector');
    const renameSessionBtn = document.getElementById('rename-session');
    const deleteSessionBtn = document.getElementById('delete-session');
    
    // Modal elements
    const sessionModal = document.getElementById('session-modal');
    const modalTitle = document.getElementById('modal-title');
    const sessionNameInput = document.getElementById('session-name-input');
    const modalCancel = document.getElementById('modal-cancel');
    const modalConfirm = document.getElementById('modal-confirm');
    
    // Magnify overlay
    const magnifyOverlay = document.getElementById('magnify-overlay');

    // ---- Session Management ----
    function createSession(name) {
      const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      sessions[sessionId] = {
        id: sessionId,
        name: name || `Session ${sessionCounter++}`,
        created: new Date().toISOString(),
        hands: [],
        counts: {},
        playedCounts: {},
        total: 0,
        totalPlayed: 0,
        vpip: 0,
        buyIn: null,
        cashOut: null,
        startTime: null,
        endTime: null,
        notes: "",
        smallBlind: null,
        bigBlind: null
      };
      return sessionId;
    }

    function switchToSession(sessionId) {
      if (!sessionId || (sessionId !== '__all__' && !sessions[sessionId])) {
        currentSessionId = null;
        updateUI();
        return;
      }
      
      console.log('Switching to session:', sessionId);
      currentSessionId = sessionId;
      sessionSelector.value = sessionId;
      updateUI();
      analyzeLuck(); // Recalculate stats when switching sessions
      saveState();
    }

    function deleteSession(sessionId) {
      if (!sessionId || !sessions[sessionId]) return;
      
      const sessionName = sessions[sessionId].name;
      if (!confirm(`Delete session "${sessionName}"? This cannot be undone.`)) return;
      
      delete sessions[sessionId];
      
      // If we deleted the current session, switch to another one or none
      if (currentSessionId === sessionId) {
        const remainingSessions = Object.keys(sessions);
        currentSessionId = remainingSessions.length > 0 ? remainingSessions[0] : null;
      }
      
      updateSessionSelector();
      updateUI();
      saveState();
    }

    function renameSession(sessionId, newName) {
      if (!sessionId || !sessions[sessionId] || !newName.trim()) return;
      
      sessions[sessionId].name = newName.trim();
      updateSessionSelector();
      saveState();
    }

    function updateSessionSelector() {
      // Clear all options except the new session option
      sessionSelector.innerHTML = `
        <option value="__new__" class="new-session">+ Create New Session</option>
      `;
      
      // Add "All Sessions" option if there are multiple sessions
      const sessionCount = Object.keys(sessions).length;
      if (sessionCount > 1) {
        const allSessionsOption = document.createElement('option');
        allSessionsOption.value = '__all__';
        allSessionsOption.textContent = '📊 All Sessions';
        allSessionsOption.style.fontWeight = 'bold';
        if (currentSessionId === '__all__') {
          allSessionsOption.selected = true;
        }
        sessionSelector.appendChild(allSessionsOption);
        
        // Add separator
        const separator = document.createElement('option');
        separator.value = '';
        separator.disabled = true;
        separator.textContent = '──';
        sessionSelector.appendChild(separator);
      }
      
      // Sort sessions by creation date (newest first)
      const sortedSessions = Object.values(sessions).sort((a, b) => 
        new Date(b.created) - new Date(a.created)
      );
      
      sortedSessions.forEach(session => {
        const option = document.createElement('option');
        option.value = session.id;
        option.textContent = session.name;
        if (session.id === currentSessionId) {
          option.selected = true;
        }
        sessionSelector.appendChild(option);
      });
      
      // If no session is selected, default to the newest session
      if (!currentSessionId && sortedSessions.length > 0) {
        currentSessionId = sortedSessions[0].id;
        sessionSelector.value = currentSessionId;
      }
    }

    function getCurrentSession() {
      if (currentSessionId === '__all__') {
        return getAggregatedSession();
      }
      return currentSessionId ? sessions[currentSessionId] : null;
    }
    
    function getAggregatedSession() {
      const allSessions = Object.values(sessions);
      if (allSessions.length === 0) return null;
      
      // Create aggregated session data
      const aggregated = {
        id: '__all__',
        name: 'All Sessions',
        created: new Date().toISOString(),
        hands: [],
        counts: {},
        playedCounts: {},
        total: 0,
        totalPlayed: 0,
        vpip: 0,
        buyIn: null,
        cashOut: null,
        startTime: null,
        endTime: null,
        notes: "",
        smallBlind: null,
        bigBlind: null
      };
      
      // Initialize all possible hand combinations to 0
      const RANKS = ['A','K','Q','J','T','9','8','7','6','5','4','3','2'];
      for (let i = 0; i < 13; i++) {
        for (let j = 0; j < 13; j++) {
          const key = keyFor(i, j);
          aggregated.counts[key] = 0;
          aggregated.playedCounts[key] = 0;
        }
      }
      
      // Merge all data from all sessions
      allSessions.forEach((session, sessionIndex) => {
        if (!session) return;
        
        // Deep copy hands to avoid reference issues
        if (session.hands && Array.isArray(session.hands)) {
          session.hands.forEach(hand => {
            if (hand && hand.key) {
              aggregated.hands.push({
                key: hand.key,
                timestamp: hand.timestamp,
                played: hand.played,
                position: hand.position,
                outcome: hand.outcome,
                pot: hand.pot,
                notes: hand.notes
              });
            }
          });
        }
        
        // Merge counts - ensure we're working with actual numbers
        if (session.counts && typeof session.counts === 'object') {
          for (const [hand, count] of Object.entries(session.counts)) {
            if (typeof count === 'number' && count > 0) {
              aggregated.counts[hand] = (aggregated.counts[hand] || 0) + count;
            }
          }
        }
        
        // Merge played counts
        if (session.playedCounts && typeof session.playedCounts === 'object') {
          for (const [hand, count] of Object.entries(session.playedCounts)) {
            if (typeof count === 'number' && count > 0) {
              aggregated.playedCounts[hand] = (aggregated.playedCounts[hand] || 0) + count;
            }
          }
        }
        
        // Add session totals
        aggregated.total += session.total || 0;
        aggregated.totalPlayed += session.totalPlayed || 0;
      });
      
      // Sort hands chronologically
      aggregated.hands.sort((a, b) => a.timestamp - b.timestamp);
      
      // Renumber positions for the merged list
      aggregated.hands.forEach((hand, index) => {
        hand.position = index + 1;
      });
      
      // Recalculate VPIP based on actual totals
      aggregated.vpip = aggregated.total > 0 ? (aggregated.totalPlayed / aggregated.total * 100) : 0;
      
      const nonZeroCounts = Object.entries(aggregated.counts).filter(([k,v]) => v > 0);
      console.log('Final aggregated session data:', {
        totalSessions: allSessions.length,
        totalHands: aggregated.total,
        totalPlayed: aggregated.totalPlayed,
        vpip: aggregated.vpip,
        handsArrayLength: aggregated.hands.length,
        nonZeroCountsLength: nonZeroCounts.length,
        sampleCounts: nonZeroCounts.slice(0, 10)
      });
      
      return aggregated;
    }

    function updateSessionInfo() {
      // Session info is now displayed in the main stats bar and topbar
      // This function is kept for compatibility but doesn't need to do anything
    }

    // ---- Modal Management ----
    function showModal(title, confirmText, placeholder = '') {
      modalTitle.textContent = title;
      modalConfirm.textContent = confirmText;
      sessionNameInput.placeholder = placeholder;
      sessionNameInput.value = '';
      sessionModal.classList.add('active');
      sessionNameInput.focus();
    }

    function hideModal() {
      sessionModal.classList.remove('active');
    }

    // ---- Core Functions (adapted for multi-session) ----
    function calculateExpectedValues() {
        let weightedSum = 0;
        let totalCombinations = 0;
        for (const hand in handStrengths) {
            const strength = handStrengths[hand];
            let combinations;
            if (hand.length === 2) { // Pair
                combinations = 6;
            } else if (hand.endsWith('s')) { // Suited
                combinations = 4;
            } else { // Off-suit
                combinations = 12;
            }
            weightedSum += strength * combinations;
            totalCombinations += combinations;
        }
        expectedMean = weightedSum / totalCombinations;

        let weightedVarianceSum = 0;
        for (const hand in handStrengths) {
            const strength = handStrengths[hand];
            let combinations;
            if (hand.length === 2) { // Pair
                combinations = 6;
            } else if (hand.endsWith('s')) { // Suited
                combinations = 4;
            } else { // Off-suit
                combinations = 12;
            }
            weightedVarianceSum += combinations * Math.pow(strength - expectedMean, 2);
        }
        const expectedVariance = weightedVarianceSum / totalCombinations;
        expectedStdDev = Math.sqrt(expectedVariance);
    }

    function keyFor(i, j) {
      if (i === j) return RANKS[i] + RANKS[i]; // pair
      const r1 = RANKS[Math.min(i, j)];
      const r2 = RANKS[Math.max(i, j)];
      const suited = i < j;
      return r1 + r2 + (suited ? 's' : 'o');
    }

    function calculateProfitLoss(session) {
      if (!session || session.buyIn === null || session.cashOut === null) {
        return null;
      }
      return session.cashOut - session.buyIn;
    }

    function formatProfitLoss(profitLoss) {
      if (profitLoss === null) return '';
      const sign = profitLoss >= 0 ? '+' : '';
      return `${sign}$${profitLoss.toFixed(2)}`;
    }

    function updateProfitLossDisplay(session) {
      if (!session) {
        profitLossAmount.textContent = '';
        profitLossAmount.className = '';
        return;
      }
      
      if (session.id === '__all__') {
        // For All Sessions, show total net profit
        const stats = calculateAggregateStats();
        const netProfit = stats.netProfit;
        
        if (stats.sessionsWithFinancialData === 0) {
          profitLossAmount.textContent = '';
          profitLossAmount.className = '';
        } else {
          profitLossAmount.textContent = formatProfitLoss(netProfit);
          profitLossAmount.className = netProfit >= 0 ? 'positive' : 'negative';
        }
      } else {
        // For individual sessions
        const profitLoss = calculateProfitLoss(session);
        
        if (profitLoss === null) {
          profitLossAmount.textContent = '';
          profitLossAmount.className = '';
        } else {
          profitLossAmount.textContent = formatProfitLoss(profitLoss);
          profitLossAmount.className = profitLoss >= 0 ? 'positive' : 'negative';
        }
      }
    }

    function buildGrid() {
      grid.innerHTML = '';
      for (let i = 0; i < 13; i++) {
        for (let j = 0; j < 13; j++) {
          const key = keyFor(i, j);
          const cell = document.createElement('button');
          cell.type = 'button';
          cell.className = 'cell' + (i === j ? ' pair' : '');
          cell.dataset.key = key;
          grid.appendChild(cell);
        }
      }
      render();
      fitGridToViewport();
    }
    
    function updateMagnifyOverlay(cell, clientX, clientY) {
      const currentBg = magnifyOverlay.style.backgroundColor;
      
      magnifyOverlay.textContent = cell.textContent;
      
      const newClasses = ['cell'];
      if (cell.classList.contains('pair')) {
        newClasses.push('pair');
      }
      magnifyOverlay.className = newClasses.join(' ');
      magnifyOverlay.id = 'magnify-overlay';
      
      if (currentBg === '#e8f5e8' || currentBg === 'rgb(232, 245, 232)') {
        magnifyOverlay.style.backgroundColor = '#e8f5e8';
      } else {
        magnifyOverlay.style.backgroundColor = cell.style.backgroundColor || '';
      }
      magnifyOverlay.style.color = cell.style.color || '';
      
      if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
        const scaledSize = cellSize * 2.0;
        magnifyOverlay.style.left = (clientX - scaledSize / 2) + 'px';
        magnifyOverlay.style.top = (clientY - 40) + 'px';
      }
    }
    
    function showMagnifyOverlay(cell, clientX, clientY) {
      if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
        magnifyOverlay.style.display = 'flex';
        magnifyOverlay.style.backgroundColor = '';
        updateMagnifyOverlay(cell, clientX, clientY);
      }
    }
    
    function hideMagnifyOverlay() {
      magnifyOverlay.style.display = 'none';
    }

    function increment(key, played = false) {
      // Can't add hands to aggregated view
      if (currentSessionId === '__all__') return;
      
      const session = getCurrentSession();
      if (!session) return;
      
      const handEntry = {
        key: key,
        timestamp: Date.now(),
        played: played,
        position: session.hands.length + 1,
        outcome: null,
        pot: null,
        notes: ""
      };
      
      session.hands.push(handEntry);
      session.counts[key] = (session.counts[key] || 0) + 1;
      session.total += 1;
      
      if (played) {
        session.playedCounts[key] = (session.playedCounts[key] || 0) + 1;
        session.totalPlayed += 1;
      }
      
      updateStats();
      render();
      updateSessionInfo();
      
      // Update session selector in case we now have multiple sessions
      updateSessionSelector();
      
      saveState();
      analyzeLuck();
    }
    
    function updateStats() {
      const session = getCurrentSession();
      if (!session) {
        vpipDisplay.textContent = 'Select session to start tracking';
        profitLossAmount.textContent = '';
        profitLossAmount.className = '';
        playStyleIndicator.classList.remove('normal', 'tight', 'loose', 'nit', 'maniac');
        playStyleIndicator.innerHTML = '&nbsp';
        return;
      }
      
      // For aggregated sessions, VPIP is already calculated correctly
      if (session.id !== '__all__') {
        session.vpip = session.total > 0 ? (session.totalPlayed / session.total * 100) : 0;
      }
      
      // Debug for aggregated sessions
      if (session.id === '__all__') {
        console.log('Updating stats for All Sessions:', {
          total: session.total,
          totalPlayed: session.totalPlayed,
          vpip: session.vpip,
          handsLength: session.hands?.length || 0
        });
      }
      
      // Update VPIP display (remove profit/loss from here)
      vpipDisplay.textContent = `VPIP: ${session.vpip.toFixed(1)}% (${session.totalPlayed}/${session.total})`;
      
      // Update profit/loss display
      updateProfitLossDisplay(session);
      
      playStyleIndicator.classList.remove('normal', 'tight', 'loose', 'nit', 'maniac');
      playStyleIndicator.innerHTML = '&nbsp';
      if (session.total == 0) {
        return
      }

      let bgColor;
      if (session.vpip < 10) {
        playStyleIndicator.textContent = 'Nit';
        playStyleIndicator.classList.add('nit');
        bgColor = '#EFD30B';
      } else if (session.vpip < 20) {
        playStyleIndicator.textContent = 'Tight';
        playStyleIndicator.className = 'tight';
        bgColor = '#3b82f6';
      } else if (session.vpip <= 30) {
        playStyleIndicator.textContent = 'Normal';
        playStyleIndicator.classList.add('normal');
        bgColor = '#10b981';
      } else if (session.vpip <= 50) {
        playStyleIndicator.textContent = 'Loose';
        playStyleIndicator.classList.add('loose');
        bgColor = '#f59e0b';
      } else {
        playStyleIndicator.textContent = 'Maniac';
        playStyleIndicator.classList.add('maniac');
        bgColor = '#ef4444';
      }
      
      const hex = bgColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      playStyleIndicator.style.color = luminance < 128 ? '#ffffff' : '#2d3748';
    }

    function undo() {
      // Can't undo in aggregated view
      if (currentSessionId === '__all__') return;
      
      const session = getCurrentSession();
      if (!session || session.hands.length === 0) return;
      
      const lastHand = session.hands.pop();
      const key = lastHand.key;
      
      if (session.counts[key] > 0) {
        session.counts[key] -= 1;
        session.total -= 1;
      }
      
      if (lastHand.played && session.playedCounts[key] > 0) {
        session.playedCounts[key] -= 1;
        session.totalPlayed -= 1;
      }
      
      updateStats();
      render();
      if (currentView === 'list') {
        renderList();
      }
      updateSessionInfo();
      
      // Update session selector in case we no longer have multiple sessions
      updateSessionSelector();
      
      saveState();
      analyzeLuck();
    }


    function toggleCounts() {
      showCounts = !showCounts;
      if (showCounts) showStrength = false;
      render();
      saveState();
    }

    function toggleStrength() {
      showStrength = !showStrength;
      if (showStrength) showCounts = false;
      render();
      saveState();
    }

    function toggleHeatmap() {
      showHeatmap = !showHeatmap;
      render();
      saveState();
    }
    
    function togglePlayed() {
      showPlayed = !showPlayed;
      
      if (showPlayed) {
        togglePlayedBtn.classList.add('toggle-active');
      } else {
        togglePlayedBtn.classList.remove('toggle-active');
      }
      
      render();
      saveState();
      analyzeLuck();
    }
    
    function switchView(view) {
      currentView = view;
      
      // Hide all containers
      gridContainer.style.display = 'none';
      listContainer.classList.remove('active');
      detailsContainer.classList.remove('active');
      
      // Remove active class from all tabs
      gridTab.classList.remove('active');
      listTab.classList.remove('active');
      detailsTab.classList.remove('active');
      
      // Show selected view
      if (view === 'grid') {
        gridContainer.style.display = 'flex';
        gridTab.classList.add('active');
        analysisResultsEl.style.display = 'block';
        analyzeLuck();
      } else if (view === 'list') {
        listContainer.classList.add('active');
        listTab.classList.add('active');
        analysisResultsEl.style.display = 'block';
        renderList();
        analyzeLuck();
      } else if (view === 'details') {
        detailsContainer.classList.add('active');
        detailsTab.classList.add('active');
        analysisResultsEl.style.display = 'none';
        loadDetailsForm();
      }
      
      saveState();
    }

    function loadDetailsForm() {
      const session = getCurrentSession();
      const isAggregated = currentSessionId === '__all__';
      
      // Disable form fields for aggregated view
      buyInInput.disabled = isAggregated;
      cashOutInput.disabled = isAggregated;
      smallBlindInput.disabled = isAggregated;
      bigBlindInput.disabled = isAggregated;
      startTimeInput.disabled = isAggregated;
      endTimeInput.disabled = isAggregated;
      sessionNotesInput.disabled = isAggregated;
      
      if (!session) {
        // Clear form when no session
        buyInInput.value = '';
        cashOutInput.value = '';
        smallBlindInput.value = '';
        bigBlindInput.value = '';
        startTimeInput.value = '';
        endTimeInput.value = '';
        sessionNotesInput.value = '';
        return;
      }
      
      if (isAggregated) {
        // Show aggregate stats instead of form
        renderAggregateStats();
        return;
      }
      
      // Restore the original form if coming from aggregate view
      restoreDetailsForm();
      
      // Load session data into form
      buyInInput.value = session.buyIn !== null ? session.buyIn : '';
      cashOutInput.value = session.cashOut !== null ? session.cashOut : '';
      smallBlindInput.value = session.smallBlind !== null ? session.smallBlind : '';
      bigBlindInput.value = session.bigBlind !== null ? session.bigBlind : '';
      startTimeInput.value = session.startTime || '';
      endTimeInput.value = session.endTime || '';
      sessionNotesInput.value = session.notes || '';
    }

    function saveDetailsForm() {
      const session = getCurrentSession();
      if (!session || currentSessionId === '__all__') return;
      
      // Parse and save form values
      session.buyIn = buyInInput.value ? parseFloat(buyInInput.value) : null;
      session.cashOut = cashOutInput.value ? parseFloat(cashOutInput.value) : null;
      session.smallBlind = smallBlindInput.value ? parseFloat(smallBlindInput.value) : null;
      session.bigBlind = bigBlindInput.value ? parseFloat(bigBlindInput.value) : null;
      session.startTime = startTimeInput.value || null;
      session.endTime = endTimeInput.value || null;
      session.notes = sessionNotesInput.value || '';
      
      // Update the display
      updateStats();
      saveState();
    }

    function calculateAggregateStats() {
      const allSessions = Object.values(sessions);
      const sessionsWithFinancialData = allSessions.filter(s => 
        s.buyIn !== null && s.buyIn !== undefined && 
        s.cashOut !== null && s.cashOut !== undefined
      );
      
      let totalBuyIn = 0;
      let totalCashOut = 0;
      let totalHands = 0;
      let totalHours = 0;
      let winSessions = 0;
      
      // Calculate totals from sessions with financial data
      sessionsWithFinancialData.forEach(session => {
        totalBuyIn += session.buyIn;
        totalCashOut += session.cashOut;
        
        // Count winning sessions
        if (session.cashOut > session.buyIn) {
          winSessions++;
        }
      });
      
      // Calculate total hands from all sessions (not just those with financial data)
      allSessions.forEach(session => {
        totalHands += session.total || 0;
      });
      
      // Calculate total hours from sessions with time data
      const sessionsWithTimeData = allSessions.filter(s => s.startTime && s.endTime);
      sessionsWithTimeData.forEach(session => {
        const start = new Date(session.startTime);
        const end = new Date(session.endTime);
        const hours = (end - start) / (1000 * 60 * 60);
        if (hours > 0) {
          totalHours += hours;
        }
      });
      
      const netProfit = totalCashOut - totalBuyIn;
      const winPercentage = sessionsWithFinancialData.length > 0 ? (winSessions / sessionsWithFinancialData.length) * 100 : 0;
      console.log(winSessions)
      console.log(sessionsWithFinancialData.length)
      console.log(winPercentage)
      const avgBuyIn = sessionsWithFinancialData.length > 0 ? totalBuyIn / sessionsWithFinancialData.length : 0;
      const avgProfit = sessionsWithFinancialData.length > 0 ? netProfit / sessionsWithFinancialData.length : 0;
      const dollarsPerHour = totalHours > 0 ? netProfit / totalHours : 0;
      
      return {
        totalBuyIn,
        totalCashOut,
        netProfit,
        totalSessions: allSessions.length,
        sessionsWithFinancialData: sessionsWithFinancialData.length,
        totalHands,
        winPercentage,
        avgBuyIn,
        avgProfit,
        dollarsPerHour,
        totalHours
      };
    }

    function prepareBankrollChartData() {
      const allSessions = Object.values(sessions);
      const sessionsWithFinancialData = allSessions
        .filter(s => s.buyIn !== null && s.buyIn !== undefined &&
                     s.cashOut !== null && s.cashOut !== undefined)
        .sort((a, b) => new Date(a.created) - new Date(b.created)); // Sort by creation date

      if (sessionsWithFinancialData.length === 0) {
        return { labels: [], data: [], sessionProfits: [], pointColors: [] };
      }

      const labels = [];
      const cumulativeBankroll = [];
      const sessionProfits = [];
      const pointColors = [];
      let runningTotal = 0;

      sessionsWithFinancialData.forEach((session, index) => {
        const sessionProfit = session.cashOut - session.buyIn;
        runningTotal += sessionProfit;

        labels.push(`${index + 1}`);
        cumulativeBankroll.push(runningTotal);
        sessionProfits.push(sessionProfit);
        pointColors.push(sessionProfit >= 0 ? '#10b981' : '#ef4444');
      });

      return { labels, data: cumulativeBankroll, sessionProfits, pointColors };
    }

    let bankrollChart = null;

    function createBankrollChart() {
      const chartData = prepareBankrollChartData();
      
      if (chartData.labels.length === 0) {
        const canvas = document.getElementById('bankrollChart');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '16px Arial';
        ctx.fillStyle = '#9CA3AF';
        ctx.textAlign = 'center';
        ctx.fillText('No financial data available', canvas.width / 2, canvas.height / 2);
        return;
      }
      
      const ctx = document.getElementById('bankrollChart').getContext('2d');
      
      if (bankrollChart) {
        bankrollChart.destroy();
      }
      
      bankrollChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: chartData.labels,
          datasets: [{
            label: 'Cumulative Bankroll',
            data: chartData.data,
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            borderWidth: 3,
            fill: true,
            tension: 0.1,
            pointBackgroundColor: chartData.pointColors,
            pointBorderColor: '#ffffff',
            pointBorderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: false
              },
              ticks: {
                callback: function(value) {
                  return '$' + value.toFixed(0);
                }
              }
            },
            x: {
              title: {
                display: true,
                text: 'Session Number'
              }
            }
          },
          plugins: {
            title: {
              display: false
            },
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  return 'Session ' + context[0].label;
                },
                label: function(context) {
                  const sessionProfit = chartData.sessionProfits[context.dataIndex];
                  return [
                    'Bankroll: $' + context.parsed.y.toFixed(2),
                    'Session P/L: ' + (sessionProfit >= 0 ? '+' : '') + '$' + sessionProfit.toFixed(2)
                  ];
                }
              }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
    }

    function renderAggregateStats() {
      const stats = calculateAggregateStats();
      
      const detailsSection = detailsContainer.querySelector('.details-section');
      detailsSection.innerHTML = `
        <h3 class="details-title">All Sessions Statistics</h3>
        
        <div class="aggregate-section">
          <h4 class="aggregate-section-title">Summary</h4>
          <div class="aggregate-stats-grid">
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value ${stats.netProfit >= 0 ? 'positive' : 'negative'}">${formatProfitLoss(stats.netProfit)}</div>
              <div class="aggregate-stat-label">Net Profit</div>
            </div>
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value">$${stats.totalBuyIn.toFixed(2)}</div>
              <div class="aggregate-stat-label">Total Buy-in</div>
            </div>
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value">$${stats.totalCashOut.toFixed(2)}</div>
              <div class="aggregate-stat-label">Total Cash-out</div>
            </div>
          </div>
        </div>
        
        <div class="aggregate-section">
          <h4 class="aggregate-section-title">Sessions</h4>
          <div class="aggregate-stats-grid">
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value">${stats.totalSessions}</div>
              <div class="aggregate-stat-label"># of Sessions</div>
            </div>
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value">${stats.totalHands}</div>
              <div class="aggregate-stat-label"># of Hands</div>
            </div>
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value ${stats.dollarsPerHour >= 0 ? 'positive' : 'negative'}">$${stats.dollarsPerHour.toFixed(2)}/hr</div>
              <div class="aggregate-stat-label">$/hr</div>
            </div>
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value">${stats.winPercentage.toFixed(1)}%</div>
              <div class="aggregate-stat-label">Win %</div>
            </div>
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value">$${stats.avgBuyIn.toFixed(2)}</div>
              <div class="aggregate-stat-label">Avg Buy-in</div>
            </div>
            <div class="aggregate-stat-card">
              <div class="aggregate-stat-value ${stats.avgProfit >= 0 ? 'positive' : 'negative'}">${formatProfitLoss(stats.avgProfit)}</div>
              <div class="aggregate-stat-label">Avg Profit</div>
            </div>
          </div>
        </div>
        
        <div class="aggregate-section">
          <h4 class="aggregate-section-title">Bankroll</h4>
          <div class="bankroll-chart-container">
            <canvas id="bankrollChart"></canvas>
          </div>
        </div>
      `;
      
      // Create the bankroll chart after DOM is updated
      setTimeout(() => {
        createBankrollChart();
      }, 100);
    }

    function restoreDetailsForm() {
      const detailsSection = detailsContainer.querySelector('.details-section');
      detailsSection.innerHTML = `
        <h3 class="details-title">Session Details</h3>
        <div class="details-grid">
          <div class="detail-field">
            <label for="buy-in">Buy In ($)</label>
            <input type="number" id="buy-in" placeholder="0.00" step="0.01" min="0">
          </div>
          <div class="detail-field">
            <label for="cash-out">Cash Out ($)</label>
            <input type="number" id="cash-out" placeholder="0.00" step="0.01" min="0">
          </div>
          <div class="detail-field">
            <label for="small-blind">Small Blind ($)</label>
            <input type="number" id="small-blind" placeholder="0.00" step="0.01" min="0">
          </div>
          <div class="detail-field">
            <label for="big-blind">Big Blind ($)</label>
            <input type="number" id="big-blind" placeholder="0.00" step="0.01" min="0">
          </div>
          <div class="detail-field">
            <label for="start-time">Start Time</label>
            <input type="datetime-local" id="start-time">
          </div>
          <div class="detail-field">
            <label for="end-time">End Time</label>
            <input type="datetime-local" id="end-time">
          </div>
          <div class="detail-field detail-field-full">
            <label for="session-notes">Notes</label>
            <textarea id="session-notes" placeholder="Session notes, observations, etc." rows="4"></textarea>
          </div>
        </div>
      `;
      
      // Re-get the input elements since we just recreated the form
      const newBuyInInput = document.getElementById('buy-in');
      const newCashOutInput = document.getElementById('cash-out');
      const newSmallBlindInput = document.getElementById('small-blind');
      const newBigBlindInput = document.getElementById('big-blind');
      const newStartTimeInput = document.getElementById('start-time');
      const newEndTimeInput = document.getElementById('end-time');
      const newSessionNotesInput = document.getElementById('session-notes');
      
      // Re-add event listeners
      newBuyInInput.addEventListener('input', debounce(saveDetailsForm, 500));
      newCashOutInput.addEventListener('input', debounce(saveDetailsForm, 500));
      newSmallBlindInput.addEventListener('input', debounce(saveDetailsForm, 500));
      newBigBlindInput.addEventListener('input', debounce(saveDetailsForm, 500));
      newStartTimeInput.addEventListener('change', saveDetailsForm);
      newEndTimeInput.addEventListener('change', saveDetailsForm);
      newSessionNotesInput.addEventListener('input', debounce(saveDetailsForm, 1000));
      
      // Update the module-level references
      buyInInput = newBuyInInput;
      cashOutInput = newCashOutInput;
      smallBlindInput = newSmallBlindInput;
      bigBlindInput = newBigBlindInput;
      startTimeInput = newStartTimeInput;
      endTimeInput = newEndTimeInput;
      sessionNotesInput = newSessionNotesInput;
    }

    function updateUI() {
      const session = getCurrentSession();
      const isAggregated = currentSessionId === '__all__';

      if (session) {
        // Enable/disable controls based on session type
        undoBtn.disabled = isAggregated; // Can't undo in aggregated view
        renameSessionBtn.disabled = isAggregated; // Can't rename "All Sessions"
        deleteSessionBtn.disabled = isAggregated; // Can't delete "All Sessions"
      } else {
        // Disable controls
        undoBtn.disabled = true;
        renameSessionBtn.disabled = true;
        deleteSessionBtn.disabled = true;
      }

      
      updateStats();
      render();
      updateSessionInfo();
      
      if (currentView === 'list') {
        renderList();
      } else if (currentView === 'details') {
        loadDetailsForm();
      }
    }

    function saveState() {
      const state = {
        sessions,
        currentSessionId,
        sessionCounter,
        currentView,
        showCounts,
        showStrength,
        showHeatmap,
        showPlayed
      };
      localStorage.setItem('pokerMultiSessionState', JSON.stringify(state));
    }

    function loadState() {
      const savedState = localStorage.getItem('pokerMultiSessionState');
      if (savedState) {
        try {
          const state = JSON.parse(savedState);
          sessions = state.sessions || {};
          currentSessionId = state.currentSessionId || null;
          sessionCounter = state.sessionCounter || 1;
          currentView = state.currentView || 'grid';
          showCounts = state.showCounts || false;
          showStrength = state.showStrength || false;
          showHeatmap = state.showHeatmap || false;
          showPlayed = state.showPlayed || false;
          
          // Ensure backwards compatibility - add missing fields to existing sessions
          Object.values(sessions).forEach(session => {
            if (session.buyIn === undefined) session.buyIn = null;
            if (session.cashOut === undefined) session.cashOut = null;
            if (session.startTime === undefined) session.startTime = null;
            if (session.endTime === undefined) session.endTime = null;
            if (session.notes === undefined) session.notes = "";
            if (session.smallBlind === undefined) session.smallBlind = null;
            if (session.bigBlind === undefined) session.bigBlind = null;
          });
          
          // Ensure current session still exists
          if (currentSessionId && !sessions[currentSessionId]) {
            currentSessionId = null;
          }
        } catch (e) {
          console.error('Failed to load state:', e);
        }
      }
      
      // If no sessions exist, create a default one
      if (Object.keys(sessions).length === 0) {
        const defaultSessionId = createSession('Session 1');
        currentSessionId = defaultSessionId;
      }
    }

    function updateCellColors() {
      const session = getCurrentSession();
      if (!session) return;
      
      const cells = grid.children;

      if (showHeatmap) {
        const strongColor = { r: 16, g: 185, b: 129 };
        const midColor = { r: 59, g: 130, b: 246 };
        const weakColor = { r: 245, g: 158, b: 11 };

        for (const cell of cells) {
            const key = cell.dataset.key;
            const strength = handStrengths[key];
            let r, g, b;

            if (strength <= 50) {
                const ratio = strength / 50;
                r = Math.round(strongColor.r + ratio * (midColor.r - strongColor.r));
                g = Math.round(strongColor.g + ratio * (midColor.g - strongColor.g));
                b = Math.round(strongColor.b + ratio * (midColor.b - strongColor.b));
            } else {
                const ratio = (strength - 50) / 50;
                r = Math.round(midColor.r + ratio * (weakColor.r - midColor.r));
                g = Math.round(midColor.g + ratio * (weakColor.g - midColor.g));
                b = Math.round(midColor.b + ratio * (weakColor.b - midColor.b));
            }
            
            cell.style.backgroundColor = `rgb(${r},${g},${b})`;

            const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            cell.style.color = luminance < 128 ? '#ffffff' : '#2d3748';
        }
      } else {
        const sourceData = showPlayed ? session.playedCounts : session.counts;
        const values = Object.values(sourceData);
        const max = Math.max(1, ...values);
        
        for (const cell of cells) {
            const key = cell.dataset.key;
            const c = sourceData[key] || 0;

            let baseColor;
            if (key.endsWith('s')) { // Suited
              baseColor = '#D8D8D8';
            } else if (key.length === 2) { // Pair
              baseColor = '#A9A9A9';
            } else { // Off-suit
              baseColor = '#FFFFFF';
            }

            if (c > 0) {
              const ratio = c / max;
              const r = 255;
              const g = Math.round(255 * (1 - ratio));
              const b = Math.round(255 * (1 - ratio));
              cell.style.backgroundColor = `rgb(${r},${g},${b})`;
              const luminance = 0.2126*r + 0.7152*g + 0.0722*b;
              cell.style.color = luminance < 128 ? '#ffffff' : '#2d3748';
            } else {
              cell.style.backgroundColor = baseColor;
              cell.style.color = '#2d3748';
            }
        }
      }
    }

    function render() {
      const session = getCurrentSession();
      if (!session) {
        // Clear grid when no session selected
        for (const cell of grid.children) {
          const key = cell.dataset.key;
          cell.textContent = key;
          cell.classList.remove('played');
          cell.style.backgroundColor = '';
          cell.style.color = '';
        }
        return;
      }
      
      for (const cell of grid.children) {
        const key = cell.dataset.key;
        const playedCount = session.playedCounts[key] || 0;
        const totalCount = session.counts[key] || 0;
        
        if (showCounts) {
          cell.textContent = showPlayed ? playedCount : totalCount;
        } else if (showStrength) {
          cell.textContent = handStrengths[key];
        } else {
          cell.textContent = key;
        }
        
        cell.classList.toggle('played', playedCount > 0);
        cell.style.display = 'flex';
      }
      updateCellColors();
    }

    function handleInteractionStart(e) {
      if (!getCurrentSession()) return;
      
      if (e.target.classList.contains('cell')) {
        isMouseDown = true;
        if (activeCell) {
          activeCell.classList.remove('active', 'playing');
        }
        activeCell = e.target;
        activeCell.classList.add('active');
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        showMagnifyOverlay(activeCell, clientX, clientY);
        
        longPressTimer = setTimeout(() => {
          if (isMouseDown && activeCell) {
            activeCell.classList.add('playing');
            magnifyOverlay.style.backgroundColor = '#e8f5e8';
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
          }
        }, 600);
        
        e.preventDefault();
      }
    }

    function handleInteractionMove(e) {
      if (isMouseDown) {
        let clientX, clientY;
        if (e.touches) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }
        
        if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
          const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
          const scaledSize = cellSize * 2.0;
          magnifyOverlay.style.left = (clientX - scaledSize / 2) + 'px';
          magnifyOverlay.style.top = (clientY - 40) + 'px';
        }
        
        const target = document.elementFromPoint(clientX, clientY);

        if (target && target.classList.contains('cell') && target !== activeCell) {
          clearTimeout(longPressTimer);
          
          if (activeCell) {
            activeCell.classList.remove('active', 'playing');
          }
          magnifyOverlay.style.backgroundColor = '';
          
          activeCell = target;
          activeCell.classList.add('active');
          
          updateMagnifyOverlay(activeCell, clientX, clientY);
          
          longPressTimer = setTimeout(() => {
            if (isMouseDown && activeCell) {
              activeCell.classList.add('playing');
              magnifyOverlay.style.backgroundColor = '#e8f5e8';
              if (navigator.vibrate) {
                navigator.vibrate(50);
              }
            }
          }, 600);
        }
        e.preventDefault();
      }
    }

    function handleInteractionEnd(e) {
      if (isMouseDown && activeCell) {
        let releaseTarget;
        if (e.touches && e.changedTouches && e.changedTouches.length > 0) {
          releaseTarget = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        } else {
          releaseTarget = e.target;
        }
        
        const gridContainer = document.getElementById('grid');
        const isOverGrid = releaseTarget && (releaseTarget.classList.contains('cell') || gridContainer.contains(releaseTarget));
        
        if (isOverGrid) {
          const key = activeCell.dataset.key;
          const wasLongPress = activeCell.classList.contains('playing');
          
          clearTimeout(longPressTimer);
          increment(key, wasLongPress);
        } else {
          clearTimeout(longPressTimer);
        }
        
        activeCell.classList.remove('active', 'playing');
        activeCell = null;
      }
      
      hideMagnifyOverlay();
      
      isMouseDown = false;
      clearTimeout(longPressTimer);
    }

    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    function saveNotes(handIndex, notes) {
      const session = getCurrentSession();
      if (!session || currentSessionId === '__all__') return;

      const hand = session.hands[handIndex];
      if (hand) {
        hand.notes = notes;
        saveState();
      }
    }

    function renderList() {
      const session = getCurrentSession();
      const isAggregated = currentSessionId === '__all__';
      listContainer.innerHTML = '';

      if (!session) return;

      const sortedHands = [...session.hands].reverse();

      sortedHands.forEach((hand, index) => {
        const handIndex = session.hands.length - 1 - index;
        const listItem = document.createElement('div');
        listItem.className = 'list-item';
        listItem.dataset.handIndex = handIndex;

        let sessionInfo = '';
        if (isAggregated) {
          const originalSession = Object.values(sessions).find(s =>
            s.hands.some(h => h.timestamp === hand.timestamp && h.key === hand.key)
          );
          sessionInfo = originalSession ? ` <span style="color: var(--color-mid); font-size: 12px;">(${originalSession.name})</span>` : '';
        }

        listItem.innerHTML = `
          <div class="list-item-hand">${hand.key}${sessionInfo}</div>
          <div class="list-item-position">#${hand.position}</div>
          <div class="list-item-actions">
            <button class="action-button notes-button" data-action="notes">Notes</button>
            <button class="toggle-switch ${hand.played ? 'played' : ''}" data-action="toggle" ${isAggregated ? 'disabled' : ''}></button>
            <button class="delete-button" data-action="delete" ${isAggregated ? 'disabled style="opacity: 0.5;"' : ''}>
              🗑️
            </button>
          </div>
          <div class="list-item-notes-container">
            <textarea class="list-item-notes" placeholder="Add notes..." ${isAggregated ? 'readonly' : ''}>${hand.notes || ''}</textarea>
          </div>
        `;

        const notesButton = listItem.querySelector('[data-action="notes"]');
        const notesContainer = listItem.querySelector('.list-item-notes-container');

        if (hand.notes && hand.notes.trim() !== '') {
          notesContainer.classList.add('active');
          notesButton.classList.add('toggle-active');
        }

        notesButton.addEventListener('click', () => {
          notesContainer.classList.toggle('active');
          notesButton.classList.toggle('toggle-active');
        });

        if (!isAggregated) {
          const toggleButton = listItem.querySelector('[data-action="toggle"]');
          const deleteButton = listItem.querySelector('[data-action="delete"]');
          const notesTextarea = listItem.querySelector('.list-item-notes');

          toggleButton.addEventListener('click', () => {
            toggleHandStatus(handIndex);
          });

          deleteButton.addEventListener('click', () => {
            deleteHand(handIndex);
          });

          notesTextarea.addEventListener('input', debounce(() => {
            saveNotes(handIndex, notesTextarea.value);
          }, 500));
        }

        listContainer.appendChild(listItem);
      });
    }
    
    function toggleHandStatus(handIndex) {
      const session = getCurrentSession();
      if (!session) return;
      
      const hand = session.hands[handIndex];
      if (!hand) return;
      
      hand.played = !hand.played;
      
      if (hand.played) {
        session.playedCounts[hand.key] = (session.playedCounts[hand.key] || 0) + 1;
        session.totalPlayed += 1;
      } else {
        session.playedCounts[hand.key] = Math.max(0, (session.playedCounts[hand.key] || 0) - 1);
        session.totalPlayed = Math.max(0, session.totalPlayed - 1);
      }
      
      updateStats();
      render();
      renderList();
      updateSessionInfo();
      saveState();
      analyzeLuck();
    }
    
    function deleteHand(handIndex) {
      const session = getCurrentSession();
      if (!session) return;
      
      const hand = session.hands[handIndex];
      if (!hand) return;
      
      session.counts[hand.key] = Math.max(0, (session.counts[hand.key] || 0) - 1);
      session.total = Math.max(0, session.total - 1);
      
      if (hand.played) {
        session.playedCounts[hand.key] = Math.max(0, (session.playedCounts[hand.key] || 0) - 1);
        session.totalPlayed = Math.max(0, session.totalPlayed - 1);
      }
      
      session.hands.splice(handIndex, 1);
      
      session.hands.forEach((h, i) => {
        h.position = i + 1;
      });
      
      updateStats();
      render();
      renderList();
      updateSessionInfo();
      saveState();
      analyzeLuck();
    }

    let histogramChart = null;

    function generateUniformDistribution(count, bins = 20) {
        const expectedFrequency = count / bins;
        return new Array(bins).fill(expectedFrequency);
    }

    function createHistogram(strengths, mean, expectedMean, expectedStdDev) {
        const binWidth = 5;
        const bins = 20;
        const actualData = new Array(bins).fill(0);
        
        // Create histogram bins for actual data
        strengths.forEach(strength => {
            const binIndex = Math.min(Math.floor(strength / binWidth), bins - 1);
            actualData[binIndex]++;
        });
        
        // Generate expected uniform distribution
        const expectedData = generateUniformDistribution(strengths.length, bins);
        
        // Calculate smoothed trend line using moving average of current, left, and right values
        const trendData = new Array(bins);
        for (let i = 0; i < bins; i++) {
            const left = i > 0 ? actualData[i - 1] : actualData[i];
            const current = actualData[i];
            const right = i < bins - 1 ? actualData[i + 1] : actualData[i];
            trendData[i] = (left + current + right) / 3;
        }
        
        // Create labels for bins
        const labels = [];
        for (let i = 0; i < bins; i++) {
            const binStart = i * binWidth;
            const binEnd = (i + 1) * binWidth;
            labels.push(`${binStart}-${binEnd}`);
        }
        
        const ctx = document.getElementById('histogramChart').getContext('2d');
        
        if (histogramChart) {
            histogramChart.destroy();
        }
        
        histogramChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Your Hands',
                    data: actualData,
                    backgroundColor: 'rgba(59, 130, 246, 0.7)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1
                }, {
                    label: 'Trend Line',
                    data: trendData,
                    type: 'line',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 3,
                    fill: false,
                    pointRadius: 4,
                    pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                    pointBorderColor: 'rgba(255, 255, 255, 1)',
                    pointBorderWidth: 2,
                    tension: 0.4,
                }, {
                    label: 'Expected Uniform',
                    data: expectedData,
                    type: 'line',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderColor: 'rgba(239, 68, 68, 0.8)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Frequency'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hand Strength (0=strongest, 100=weakest)'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: false,
                        text: 'Hand Strength Distribution vs Expected'
                    },
                    legend: {
                          display: true,
                          position: 'top',
                          labels: {
                            filter: function(legendItem, chartData) {
                                return legendItem.text != 'Trend Line';
                            }
                          }
                    }
                }
            }
        });
    }

    function analyzeLuck() {
        const session = getCurrentSession();
        if (!session) {
          analysisResultsEl.innerHTML = '';
          return;
        }
        
        const handsToAnalyze = showPlayed ? session.hands.filter(hand => hand.played) : session.hands;
        
        if (handsToAnalyze.length === 0) {
            analysisResultsEl.innerHTML = '';
            return;
        }

        const strengths = handsToAnalyze.map(hand => handStrengths[hand.key]);
        const mean = strengths.reduce((a, b) => a + b, 0) / strengths.length;
        const zScore = (mean - expectedMean) / (expectedStdDev / Math.sqrt(handsToAnalyze.length));

        let category, categoryClass, interpretation;
        if (zScore < -1.5) {
            category = "High Roll 🚀";
            categoryClass = "high-roll";
            interpretation = "You're getting significantly better than expected hands!";
        } else if (zScore > 1.5) {
            category = "Low Roll 😩";
            categoryClass = "low-roll";
            interpretation = "You're experiencing significantly worse than expected luck with your dealt hands.";
        } else {
            category = "Expected 📊";
            categoryClass = "expected";
            interpretation = "Your dealt hands are within normal expected variance.";
        }

        analysisResultsEl.innerHTML = `
            <div class="results">
                <div class="luck-category ${categoryClass}">${category}</div>
                
                <div class="histogram-container">
                    <h3 class="histogram-title">Hand Strength Distribution</h3>
                    <div class="chart-wrapper">
                        <canvas id="histogramChart"></canvas>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${mean.toFixed(1)}</div>
                        <div class="stat-label">Average Strength</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${zScore.toFixed(2)}</div>
                        <div class="stat-label">Z-Score</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${Math.sqrt(strengths.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / (strengths.length - 1)).toFixed(1)}</div>
                        <div class="stat-label">Std Deviation</div>
                    </div>
                </div>
                
                <div class="explanation">
                    <h3>📈 Statistical Analysis</h3>
                    <p><strong>Interpretation:</strong> ${interpretation}</p>
                    <p><strong>Z-Score Explained:</strong> ${Math.abs(zScore).toFixed(2)} standard deviations ${zScore >= 0 ? 'above' : 'below'} expected. Values beyond ±1.5 are considered significantly different from normal.</p>
                    <p><strong>Your Average:</strong> ${mean.toFixed(1)} vs Expected: ${expectedMean.toFixed(1)} (scale: 0-100)</p>
                    <p><strong>Histogram:</strong> Blue bars show your actual hand distribution. Green trend line smooths your data to highlight patterns and deviations. Red line shows the expected uniform distribution for comparison.</p>
                </div>
            </div>
        `;
        
        // Create histogram after DOM is updated
        setTimeout(() => {
            createHistogram(strengths, mean, expectedMean, expectedStdDev);
        }, 100);
    }

    function fitGridToViewport() {
      const root = document.documentElement;
      const vw = document.documentElement.clientWidth;
      
      let chosenGap;
      if (vw < 768) chosenGap = 0;
      else chosenGap = 4;
      
      root.style.setProperty('--gap', chosenGap + 'px');

      let containerPadding, bodyPadding;
      if (vw < 480) {
        containerPadding = 24;
        bodyPadding = 0;
      } else {
        containerPadding = 40;
        bodyPadding = 40;
      }
      
      const gridWidth = vw - containerPadding - bodyPadding;

      const MAX_CELL = vw < 480 ? 100 : 56;
      const MIN_CELL = 18;

      const ideal = Math.floor((gridWidth - chosenGap * 12) / 13);
      const cell = Math.max(MIN_CELL, Math.min(MAX_CELL, ideal));
      root.style.setProperty('--cell', cell + 'px');

      const radius = Math.max(5, Math.round(cell / 10));
      root.style.setProperty('--radius', radius + 'px');
    }

    // ---- Event Listeners ----
    undoBtn.addEventListener('click', undo);
    toggleBtn.addEventListener('click', toggleCounts);
    toggleStrengthBtn.addEventListener('click', toggleStrength);
    toggleHeatmapBtn.addEventListener('click', toggleHeatmap);
    togglePlayedBtn.addEventListener('click', togglePlayed);
    
    gridTab.addEventListener('click', () => switchView('grid'));
    listTab.addEventListener('click', () => switchView('list'));
    detailsTab.addEventListener('click', () => switchView('details'));
    
    // Details form events
    buyInInput.addEventListener('input', debounce(saveDetailsForm, 500));
    cashOutInput.addEventListener('input', debounce(saveDetailsForm, 500));
    smallBlindInput.addEventListener('input', debounce(saveDetailsForm, 500));
    bigBlindInput.addEventListener('input', debounce(saveDetailsForm, 500));
    startTimeInput.addEventListener('change', saveDetailsForm);
    endTimeInput.addEventListener('change', saveDetailsForm);
    sessionNotesInput.addEventListener('input', debounce(saveDetailsForm, 1000));
    
    // Session management events
    sessionSelector.addEventListener('change', (e) => {
      if (e.target.value === '__new__') {
        showModal('Create New Session', 'Create', 'Enter session name...');
        // Reset selector to current session or empty
        setTimeout(() => {
          if (currentSessionId) {
            sessionSelector.value = currentSessionId;
          } else {
            updateSessionSelector();
          }
        }, 0);
      } else if (e.target.value === '__all__') {
        switchToSession('__all__');
      } else {
        switchToSession(e.target.value);
      }
    });
    
    renameSessionBtn.addEventListener('click', () => {
      const session = getCurrentSession();
      if (!session) return;
      sessionNameInput.value = session.name;
      showModal('Rename Session', 'Rename', 'Enter new name...');
    });
    
    deleteSessionBtn.addEventListener('click', () => {
      if (currentSessionId) {
        deleteSession(currentSessionId);
      }
    });
    
    // Modal events
    modalCancel.addEventListener('click', hideModal);
    
    modalConfirm.addEventListener('click', () => {
      const name = sessionNameInput.value.trim();
      if (!name) return;
      
      if (modalTitle.textContent === 'Create New Session') {
        const newSessionId = createSession(name);
        switchToSession(newSessionId);
        updateSessionSelector();
      } else if (modalTitle.textContent === 'Rename Session' && currentSessionId) {
        renameSession(currentSessionId, name);
      }
      
      hideModal();
    });
    
    sessionNameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        modalConfirm.click();
      } else if (e.key === 'Escape') {
        modalCancel.click();
      }
    });
    
    // Grid interaction events
    grid.addEventListener('mousedown', handleInteractionStart);
    grid.addEventListener('mousemove', handleInteractionMove);
    document.addEventListener('mouseup', handleInteractionEnd);

    grid.addEventListener('touchstart', handleInteractionStart, { passive: false });
    grid.addEventListener('touchmove', handleInteractionMove, { passive: false });
    grid.addEventListener('touchend', handleInteractionEnd);

    // Responsive events
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(fitGridToViewport, 100);
    }, { passive: true });
    window.addEventListener('orientationchange', () => {
      setTimeout(fitGridToViewport, 200);
    });

    // ---- Import/Export Functions ----
    function exportData() {
      try {
        // Get the current state and extract only sessions data
        const savedState = localStorage.getItem('pokerMultiSessionState');
        let sessionsData = null;

        if (savedState) {
          try {
            const state = JSON.parse(savedState);
            sessionsData = state.sessions || {};
          } catch (e) {
            console.warn('Could not parse saved state');
          }
        }

        const exportData = {
          sessions: JSON.stringify(sessionsData),
          exportedAt: new Date().toISOString(),
          version: '1.0'
        };

        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });

        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `poker-tracker-data-${new Date().toISOString().split('T')[0]}.json`;
        link.click();

        URL.revokeObjectURL(link.href);

        console.log('Data exported successfully');
      } catch (error) {
        console.error('Error exporting data:', error);
        alert('Error exporting data. Please try again.');
      }
    }

    // Helper function to generate a simple hash from session data
    function generateSessionHash(sessionData) {
      // Create a string from the core session data (excluding name and created timestamp)
      const coreData = {
        hands: sessionData.hands || [],
        buyIn: sessionData.buyIn,
        cashOut: sessionData.cashOut,
        smallBlind: sessionData.smallBlind,
        bigBlind: sessionData.bigBlind,
        startTime: sessionData.startTime,
        endTime: sessionData.endTime,
        notes: sessionData.notes
      };

      const dataString = JSON.stringify(coreData);

      // Simple hash function
      let hash = 0;
      for (let i = 0; i < dataString.length; i++) {
        const char = dataString.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }

      // Convert to hex and take first 5 characters
      return Math.abs(hash).toString(16).substring(0, 5);
    }

    function importData(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const importData = JSON.parse(e.target.result);

          // Validate the imported data structure
          if (!importData.hasOwnProperty('sessions')) {
            alert('Invalid file format. Please select a valid poker tracker export file.');
            return;
          }

          // Handle case where there are no sessions (sessions: null)
          if (importData.sessions === null) {
            alert('This export file contains no session data. Nothing to import.');
            return;
          }

          // Parse the imported sessions
          const importedSessions = JSON.parse(importData.sessions);
          if (!importedSessions || typeof importedSessions !== 'object') {
            alert('Invalid sessions data in the import file.');
            return;
          }

          // Get existing sessions from the app's current state
          let existingSessions = {};
          const savedState = localStorage.getItem('pokerMultiSessionState');
          if (savedState) {
            try {
              const state = JSON.parse(savedState);
              existingSessions = state.sessions || {};
            } catch (e) {
              console.warn('Could not parse existing state, starting fresh');
              existingSessions = {};
            }
          }

          // Create a map of existing session hashes for duplicate detection
          const existingHashes = new Set();
          for (const sessionData of Object.values(existingSessions)) {
            const hash = generateSessionHash(sessionData);
            existingHashes.add(hash);
          }

          // Count sessions for user confirmation
          const importedSessionCount = Object.keys(importedSessions).length;
          const existingSessionCount = Object.keys(existingSessions).length;

          // Confirm import
          const confirmMessage = existingSessionCount > 0
            ? `This will add ${importedSessionCount} sessions to your existing ${existingSessionCount} sessions. Continue?`
            : `This will import ${importedSessionCount} sessions. Continue?`;

          if (!confirm(confirmMessage)) {
            return;
          }

          // Process imported sessions with conflict resolution and duplicate detection
          let conflictsCount = 0;
          let duplicatesSkipped = 0;
          let sessionsAdded = 0;

          // Get next available session counter
          let maxSessionNumber = 0;
          for (const sessionId in existingSessions) {
            const sessionNum = parseInt(sessionId.replace('session-', '')) || 0;
            maxSessionNumber = Math.max(maxSessionNumber, sessionNum);
          }
          // Get current session counter from app state
          let currentCounter = 1;
          if (savedState) {
            try {
              const state = JSON.parse(savedState);
              currentCounter = state.sessionCounter || 1;
            } catch (e) {
              // Use default
            }
          }
          let nextSessionNumber = Math.max(currentCounter, maxSessionNumber + 1);

          for (const [sessionId, sessionData] of Object.entries(importedSessions)) {
            const sessionHash = generateSessionHash(sessionData);

            // Check if this is a duplicate session based on data hash
            if (existingHashes.has(sessionHash)) {
              duplicatesSkipped++;
              continue;
            }

            // If session ID already exists, create a new ID and append hash to name
            let finalSessionId = sessionId;
            let finalSessionData = { ...sessionData };

            if (existingSessions[sessionId]) {
              conflictsCount++;
              finalSessionId = `session-${nextSessionNumber}`;
              nextSessionNumber++;

              // Append hash to session name for identification
              const originalName = sessionData.name || 'Poker Session';
              finalSessionData.name = `${originalName} (${sessionHash})`;
            }

            // Add the session
            existingSessions[finalSessionId] = finalSessionData;
            existingHashes.add(sessionHash);
            sessionsAdded++;
          }

          // Update the app's state with merged sessions and new counter
          const updatedState = savedState ? JSON.parse(savedState) : {};
          updatedState.sessions = existingSessions;
          updatedState.sessionCounter = nextSessionNumber;

          // Save updated state back to localStorage
          localStorage.setItem('pokerMultiSessionState', JSON.stringify(updatedState));

          // Update the app's internal variables immediately
          sessions = existingSessions;
          sessionCounter = nextSessionNumber;

          // Show success message with details
          let successMessage = `Successfully imported ${sessionsAdded} sessions!`;
          if (conflictsCount > 0) {
            successMessage += `\n\n${conflictsCount} sessions had ID conflicts and were renamed with hash identifiers.`;
          }
          if (duplicatesSkipped > 0) {
            successMessage += `\n\n${duplicatesSkipped} duplicate sessions were skipped (already exist with same data).`;
          }
          successMessage += '\n\nThe page will now reload to reflect the imported data.';

          alert(successMessage);
          location.reload();

        } catch (error) {
          console.error('Error importing data:', error);
          alert('Error importing data. Please check the file format and try again.');
        }
      };
      reader.readAsText(file);
    }

    // ---- Import/Export Event Listeners ----
    document.getElementById('export-data').addEventListener('click', exportData);

    document.getElementById('import-data').addEventListener('click', function() {
      document.getElementById('file-input').click();
    });

    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        importData(file);
      }
      // Reset the input so the same file can be selected again
      e.target.value = '';
    });

    // ---- Initialize ----
    calculateExpectedValues();
    loadState();
    updateSessionSelector();
    buildGrid();
    switchView(currentView);
    updateUI();

    if (showPlayed) {
      togglePlayedBtn.classList.add('toggle-active');
    }

    analyzeLuck();
  </script>
</body>
</html>
