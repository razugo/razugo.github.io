<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Poker Starting-Hand Clicker</title>
  <style>
    :root { --cell: 54px; --gap: 6px; --radius: 8px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif; margin: 16px; background: #f7f7f7; color: #111; }

    #topbar { position: sticky; top: 0; z-index: 10; display: flex; align-items: center; gap: 12px; margin-bottom: 12px; padding-bottom: 8px; background: linear-gradient(#f7f7f7, rgba(247,247,247,0.85)); backdrop-filter: saturate(180%) blur(6px); }
    #total { font-weight: 700; font-size: clamp(16px, 3.7vw, 20px); padding: 8px 12px; background: #fff; border: 1px solid #ddd; border-radius: 10px; }
    button { padding: 10px 14px; border: 1px solid #bbb; border-radius: 12px; background: #fff; cursor: pointer; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
    button:active { transform: translateY(1px); }

    #grid { width: 100%; display: grid; grid-template-columns: repeat(13, var(--cell)); grid-auto-rows: var(--cell); gap: var(--gap); overflow-x: hidden; }

    .cell { display: flex; align-items: center; justify-content: center; text-align: center; border: 1px solid #d7d7d7; border-radius: var(--radius); background: #fff; user-select: none; cursor: pointer; transition: background-color 80ms linear, color 80ms linear, transform 40ms ease; font-size: clamp(9px, calc(var(--cell) * 0.33), 16px); padding: 0; line-height: 1.05; min-width: var(--cell); min-height: var(--cell); white-space: nowrap; overflow: hidden; }
    .cell.pair { font-weight: 600; }
    .cell:active { transform: scale(0.98); }

    .note { margin-top: 10px; font-size: 12px; color: #666; }

    /* Desktop-ish defaults */
    @media (min-width: 900px) { body { margin: 24px; } }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="total">Total: 0</div>
    <button id="toggleCounts">Toggle Counts</button>
    <button id="undo">Undo</button>
    <button id="reset">Reset</button>
  </div>

  <div id="grid" aria-label="13 by 13 poker starting-hand grid"></div>
  <div class="note">Tap a cell to increment its counter. Colors scale from white (0) toward red as counts increase.</div>

  <script>
    // ---- Config ----
    const RANKS = ['A','K','Q','J','T','9','8','7','6','5','4','3','2']; // descending

    // ---- State ----
    let counts = {}; // key -> integer
    let total = 0;
    const history = [];
    let showCounts = false;

    // ---- Elements ----
    const grid = document.getElementById('grid');
    const totalEl = document.getElementById('total');
    const resetBtn = document.getElementById('reset');
    const undoBtn = document.getElementById('undo');
    const toggleBtn = document.getElementById('toggleCounts');

    // Compose the canonical key for a grid position
    function keyFor(i, j) {
      if (i === j) return RANKS[i] + RANKS[i]; // pair
      const r1 = RANKS[Math.min(i, j)];
      const r2 = RANKS[Math.max(i, j)];
      const suited = i < j;
      return r1 + r2 + (suited ? 's' : 'o');
    }

    function buildGrid() {
      grid.innerHTML = '';
      for (let i = 0; i < 13; i++) {
        for (let j = 0; j < 13; j++) {
          const key = keyFor(i, j);
          counts[key] = counts[key] || 0;
          const cell = document.createElement('button');
          cell.type = 'button';
          cell.className = 'cell' + (i === j ? ' pair' : '');
          cell.dataset.key = key;
          cell.addEventListener('click', () => increment(key));
          grid.appendChild(cell);
        }
      }
      render();
      fitGridToViewport();
    }

    function increment(key) {
      history.push(key);
      counts[key] = (counts[key] || 0) + 1;
      total += 1;
      render();
      saveState();
    }

    function undo() {
      if (history.length === 0) return;
      const lastKey = history.pop();
      if (counts[lastKey] > 0) {
        counts[lastKey] -= 1;
        total -= 1;
      }
      render();
      saveState();
    }

    function resetAll() {
      for (const k in counts) counts[k] = 0;
      total = 0;
      history.length = 0;
      render();
      saveState();
    }

    function toggleCounts() {
      showCounts = !showCounts;
      render();
      saveState();
    }

    function saveState() {
      const state = { counts, total, history, showCounts };
      localStorage.setItem('pokerClickerState', JSON.stringify(state));
    }

    function loadState() {
      const savedState = localStorage.getItem('pokerClickerState');
      if (savedState) {
        const state = JSON.parse(savedState);
        counts = state.counts || {};
        total = state.total || 0;
        showCounts = state.showCounts || false;
        if (state.history) {
            history.push(...state.history);
        }
      }
    }

    // Compute and apply colors, scaling to the current max cell count.
    function updateColors() {
      const cells = grid.children;
      const values = Object.values(counts);
      const max = Math.max(1, ...values);
      for (const cell of cells) {
        const c = counts[cell.dataset.key] || 0;
        const ratio = c / max; // 0..1
        const r = 255;
        const g = Math.round(255 * (1 - ratio));
        const b = Math.round(255 * (1 - ratio));
        cell.style.backgroundColor = `rgb(${r},${g},${b})`; // white -> red
        const luminance = 0.2126*r + 0.7152*g + 0.0722*b;
        cell.style.color = luminance < 140 ? '#fff' : '#111';
      }
    }

    function render() {
      totalEl.textContent = 'Total: ' + total;
      for (const cell of grid.children) {
        const key = cell.dataset.key;
        if (showCounts) {
          cell.textContent = counts[key] || 0;
        } else {
          cell.textContent = key;
        }
      }
      updateColors();
    }

    // ---- Responsive sizing ----
    function fitGridToViewport() {
      const root = document.documentElement;
      const vw = document.documentElement.clientWidth;
      // Choose a tighter gap on phones
      const chosenGap = vw <= 420 ? 2 : (vw <= 820 ? 4 : 6);
      root.style.setProperty('--gap', chosenGap + 'px');

      // Measure actual grid width to avoid overflow and host banners
      const rect = grid.getBoundingClientRect();
      const gridWidth = rect.width || (vw - 32);

      const MAX_CELL = 56; // desktop/tablet cap similar to first iteration
      const MIN_CELL = 18; // smaller minimum to prevent wrapping

      const ideal = Math.floor((gridWidth - chosenGap * 12 - 1) / 13);
      const cell = Math.max(MIN_CELL, Math.min(MAX_CELL, ideal));
      root.style.setProperty('--cell', cell + 'px');

      // Adapt border radius so small cells don't look like circles
      const radius = Math.max(3, Math.round(cell * 0.18));
      root.style.setProperty('--radius', radius + 'px');
    }

    resetBtn.addEventListener('click', resetAll);
    undoBtn.addEventListener('click', undo);
    toggleBtn.addEventListener('click', toggleCounts);
    window.addEventListener('resize', fitGridToViewport, { passive: true });
    window.addEventListener('orientationchange', fitGridToViewport);

    // Initialize
    loadState();
    buildGrid();
  </script>
</body>
</html>