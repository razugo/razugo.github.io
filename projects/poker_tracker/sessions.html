---
title: PokerTracker - Sessions
nav_id: sessions
---

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>{{ page.title | default: "PokerTracker" }}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/slim-select@2/dist/slimselect.min.css">
  <link rel="stylesheet" href="styles/main.css">
</head>
<body>
  {% include_relative components/nav-bar.html %}

  <main>
    <div class="container">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
    <h1>Sessions</h1>
    <div style="display: flex; gap: 1rem;">
      <button class="btn" onclick="goToActiveSession()" id="liveSessionBtn">Live Session</button>
      <button class="btn btn-primary" onclick="PokerTracker.Modal.showNewSessionModal()">+ New Session</button>
    </div>
  </div>

  <!-- Filters -->
  <div class="filters">
    <div class="filter-field">
      <label class="filter-label" for="sessionSearch">Session Name</label>
      <input type="text" class="filter-input" placeholder="Name contains" id="sessionSearch">
    </div>
    <div class="filter-field">
      <label class="filter-label" for="gameFilter">Game</label>
      <select class="filter-input" id="gameFilter">
        <option value="" data-placeholder="true"></option>
      </select>
    </div>
    <div class="filter-field">
      <label class="filter-label" for="dateFrom">From Date</label>
      <input type="text" class="filter-input date-picker-input" id="dateFrom" placeholder="YYYY-MM-DD" autocomplete="off">
    </div>
    <div class="filter-field">
      <label class="filter-label" for="dateTo">To Date</label>
      <input type="text" class="filter-input date-picker-input" id="dateTo" placeholder="YYYY-MM-DD" autocomplete="off">
    </div>
    <div class="filter-field">
      <label class="filter-label" for="profitFilter">Results</label>
      <select class="filter-input" id="profitFilter">
        <option value="" data-placeholder="true"></option>
        <option value="positive">Winning</option>
        <option value="negative">Losing</option>
      </select>
    </div>
  <div class="filter-field filter-button">
    <button type="button" class="btn btn-primary session-filter-apply" id="sessionFilterApplyBtn" aria-label="Apply session filters">Search</button>
  </div>
</div>

  <div class="sessions-summary" id="sessionsSummary">
    <!-- Populated by JavaScript -->
  </div>

  <!-- Sessions Table (Desktop) -->
  <div class="card desktop-view">
    <div class="card-content">
      <div class="table-container sessions-table-container">
        <table class="table sessions-table">
        <thead>
          <tr>
            <th>Date</th>
            <th>Session</th>
            <th>Game</th>
            <th>Duration</th>
            <th class="col-stake">Buy-in</th>
            <th class="col-stake">Cash-out</th>
            <th>P&L</th>
            <th class="col-hands">Hands</th>
            <th>VPIP</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="sessionsTableBody">
          <!-- Populated by JavaScript -->
        </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Sessions Cards (Mobile) -->
  <div class="mobile-view">
    <div id="sessionsCardContainer">
      <!-- Populated by JavaScript -->
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    let dateFromPicker = null;
    let dateToPicker = null;

    const syncDateFromConstraints = () => {
      if (!PokerTracker?.DatePickers || !dateFromPicker || !dateToPicker) return;
      const fromDate = dateFromPicker.selectedDates?.[0] || null;
      dateToPicker.set('minDate', fromDate || null);

      if (!fromDate) return;

      const toDate = dateToPicker.selectedDates?.[0] || null;
      if (toDate && toDate < fromDate) {
        PokerTracker.DatePickers.setDate('dateTo', fromDate, true);
      }
    };

    const syncDateToConstraints = () => {
      if (!PokerTracker?.DatePickers || !dateFromPicker || !dateToPicker) return;
      const toDate = dateToPicker.selectedDates?.[0] || null;
      dateFromPicker.set('maxDate', toDate || null);

      if (!toDate) return;

      const fromDate = dateFromPicker.selectedDates?.[0] || null;
      if (fromDate && fromDate > toDate) {
        PokerTracker.DatePickers.setDate('dateFrom', toDate, true);
      }
    };

    if (PokerTracker?.DatePickers) {
      dateFromPicker = PokerTracker.DatePickers.initDateField('dateFrom', {
        altInput: true,
        altFormat: 'M j, Y',
        altInputClass: 'filter-input flatpickr-alt-input',
        clearLabel: 'Clear',
        onChange: syncDateFromConstraints
      });

      dateToPicker = PokerTracker.DatePickers.initDateField('dateTo', {
        altInput: true,
        altFormat: 'M j, Y',
        altInputClass: 'filter-input flatpickr-alt-input',
        clearLabel: 'Clear',
        onChange: syncDateToConstraints
      });

      syncDateFromConstraints();
      syncDateToConstraints();
    }

    if (PokerTracker?.Dropdowns) {
      PokerTracker.Dropdowns.init('gameFilter', {
        placeholder: 'All games',
        placeholderText: 'All games',
        settings: {
          allowDeselect: true,
          showSearch: true,
          placeholderText: 'All games'
        }
      });

      PokerTracker.Dropdowns.init('profitFilter', {
        placeholder: 'All results',
        placeholderText: 'All results',
        settings: {
          allowDeselect: true,
          showSearch: false,
          placeholderText: 'All results'
        }
      });
    }

    populateGameFilter();
    renderSessions();
    setupFilters();
    checkActiveSession();

    document.addEventListener('pokertracker:live-session-change', function() {
      checkActiveSession();
      populateGameFilter();
      applyFilters();
    });

    window.addEventListener('resize', updateSessionsTableResponsiveState);
  });

  function renderSessions(sessions = PokerTracker.DataStore.getSessions()) {
    const tbody = document.getElementById('sessionsTableBody');
    const cardContainer = document.getElementById('sessionsCardContainer');

    if (!tbody || !cardContainer) return;

    const orderedSessions = [...sessions].sort((a, b) => {
      const valueA = PokerTracker.DataStore.getSessionSortValue(a);
      const valueB = PokerTracker.DataStore.getSessionSortValue(b);
      return valueB - valueA; // Most recent first
    });

    renderSessionsSummary(orderedSessions);

    if (orderedSessions.length === 0) {
      tbody.innerHTML = '<tr><td colspan="10" class="sessions-empty">No sessions match the current filters.</td></tr>';
      cardContainer.innerHTML = '<div class="sessions-empty">No sessions match the current filters.</div>';
      updateSessionsTableResponsiveState();
      return;
    }

    tbody.innerHTML = orderedSessions.map(session => {
      const game = PokerTracker.DataStore.getGame(session.gameId);
      const profit = (session.cashOut || 0) - (session.buyIn || 0);
      const handsCount = session.total || 0;
      const vpip = (session.vpip || 0).toFixed(1);
      const sessionDate = PokerTracker.DataStore.getSessionDate(session);

      let durationMinutes = 0;
      if (typeof session.durationHours === 'number' && Number.isFinite(session.durationHours) && session.durationHours > 0) {
        durationMinutes = session.durationHours * 60;
      } else if (session.startTime && session.endTime) {
        const start = new Date(session.startTime);
        const end = new Date(session.endTime);
        if (!Number.isNaN(start.getTime()) && !Number.isNaN(end.getTime())) {
          durationMinutes = Math.max(0, (end.getTime() - start.getTime()) / (1000 * 60));
        }
      } else if (session.startTime) {
        const start = new Date(session.startTime);
        if (!Number.isNaN(start.getTime())) {
          durationMinutes = Math.max(0, (Date.now() - start.getTime()) / (1000 * 60));
        }
      } else if (handsCount > 0) {
        durationMinutes = handsCount * 2;
      }

      const baseName = session.name || game?.name || 'Session';
      const sessionLabel = baseName;

      return `
        <tr>
          <td>${sessionDate || '-'}</td>
          <td>${sessionLabel || '-'}</td>
          <td>${game?.name || '-'}</td>
          <td>${durationMinutes > 0 ? PokerTracker.Utils.formatDuration(Math.round(durationMinutes)) : '-'}</td>
          <td class="col-stake">${PokerTracker.Utils.formatCurrency(session.buyIn || 0)}</td>
          <td class="col-stake">${PokerTracker.Utils.formatCurrency(session.cashOut || 0)}</td>
          <td class="${profit >= 0 ? 'positive' : 'negative'}">${profit >= 0 ? '+' : ''}${PokerTracker.Utils.formatCurrency(profit)}</td>
          <td class="col-hands">${handsCount}</td>
          <td>${vpip}%</td>
          <td>
            <div class="session-actions">
              <button class="action-menu-btn" onclick="showActionMenu(this, '${session.id}')">⋮</button>
            </div>
          </td>
        </tr>
      `;
    }).join('');

    cardContainer.innerHTML = orderedSessions.map(session => {
      const game = PokerTracker.DataStore.getGame(session.gameId);
      const profit = (session.cashOut || 0) - (session.buyIn || 0);
      const sessionDate = PokerTracker.DataStore.getSessionDate(session);
      const baseName = session.name || game?.name || 'Session';

      return `
        <div class="session-card">
          <div class="session-card-content">
            <div class="session-card-top">
              <span class="session-card-title">${baseName || '-'}</span>
              <span class="session-card-game">${game?.name || '-'}</span>
            </div>
            <div class="session-card-bottom">
              <span class="session-card-date">${sessionDate || '-'}</span>
              <span class="session-card-pnl ${profit >= 0 ? 'positive' : 'negative'}">
                ${profit >= 0 ? '+' : ''}${PokerTracker.Utils.formatCurrency(profit)}
              </span>
            </div>
          </div>
          <div class="session-card-actions session-actions">
            <button class="action-menu-btn" onclick="showActionMenu(this, '${session.id}')">⋮</button>
          </div>
        </div>
      `;
    }).join('');
    updateSessionsTableResponsiveState();
  }

  window.populateSessionsTable = renderSessions;

  function renderSessionsSummary(sessions) {
    const summaryEl = document.getElementById('sessionsSummary');
    if (!summaryEl) return;

    const totalSessions = sessions.length;
    let totalHands = 0;
    let totalPlayed = 0;
    let totalDurationMinutes = 0;

    sessions.forEach(session => {
      const dealt = session.total || 0;
      const played = session.totalPlayed || 0;
      totalHands += dealt;
      totalPlayed += played;

      // Calculate duration for this session
      let durationMinutes = 0;
      if (typeof session.durationHours === 'number' && Number.isFinite(session.durationHours) && session.durationHours > 0) {
        durationMinutes = session.durationHours * 60;
      } else if (session.startTime && session.endTime) {
        const start = new Date(session.startTime);
        const end = new Date(session.endTime);
        if (!Number.isNaN(start.getTime()) && !Number.isNaN(end.getTime())) {
          durationMinutes = Math.max(0, (end.getTime() - start.getTime()) / (1000 * 60));
        }
      } else if (session.startTime) {
        const start = new Date(session.startTime);
        if (!Number.isNaN(start.getTime())) {
          durationMinutes = Math.max(0, (Date.now() - start.getTime()) / (1000 * 60));
        }
      } else if (dealt > 0) {
        durationMinutes = dealt * 2;
      }
      totalDurationMinutes += durationMinutes;
    });

    const vpipValue = totalHands > 0 ? ((totalPlayed / totalHands) * 100).toFixed(1) : null;

    summaryEl.innerHTML = `
      <div class="summary-card">
        <span class="summary-label">Sessions</span>
        <span class="summary-value">${totalSessions}</span>
      </div>
      <div class="summary-card">
        <span class="summary-label">VPIP</span>
        <span class="summary-value">${vpipValue !== null ? `${vpipValue}%` : '-'}</span>
        <span class="summary-subvalue">${totalPlayed.toLocaleString()} / ${totalHands.toLocaleString()}</span>
      </div>
      <div class="summary-card">
        <span class="summary-label">Total Duration</span>
        <span class="summary-value">${totalDurationMinutes > 0 ? PokerTracker.Utils.formatDuration(Math.round(totalDurationMinutes)) : '-'}</span>
      </div>`;
  }

  function updateSessionsTableResponsiveState() {
    const tableEl = document.querySelector('.sessions-table');
    if (!tableEl) return;

    const containerEl = tableEl.closest('.table-container');
    const hideHands = window.matchMedia('(max-width: 1100px)').matches;
    const hideStakes = window.matchMedia('(max-width: 900px)').matches;

    tableEl.dataset.hideHands = hideHands ? 'true' : 'false';
    tableEl.dataset.hideStakes = hideStakes ? 'true' : 'false';

    if (containerEl) {
      containerEl.classList.toggle('scrollable', tableEl.scrollWidth > containerEl.clientWidth);
    }
  }

  function deleteSession(sessionId) {
    console.log('deleteSession called with sessionId:', sessionId);
    const session = PokerTracker.DataStore.getSession(sessionId);
    console.log('Retrieved session:', session);

    if (!session) {
      console.error('Session not found for ID:', sessionId);
      console.error('Session not found');
      return;
    }

    const handsCount = session.total || 0;

    if (confirm(`Are you sure you want to delete this session? This will permanently delete ${handsCount} hands and cannot be undone.`)) {
      PokerTracker.DataStore.deleteSession(sessionId);
      console.error('Session deleted successfully!');
      applyFilters();
      checkActiveSession();
    }
  }

  function setupFilters() {
    const applyButton = document.getElementById('sessionFilterApplyBtn');
    if (applyButton) {
      applyButton.addEventListener('click', applyFilters);
    }

    ['sessionSearch', 'dateFrom', 'dateTo'].forEach(id => {
      const input = document.getElementById(id);
      if (input) {
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            applyFilters();
          }
        });
      }

      const picker = PokerTracker?.DatePickers?.get(id);
      if (picker?.altInput) {
        picker.altInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            applyFilters();
          }
        });
      }
    });
  }

  function populateGameFilter() {
    const gameSelect = document.getElementById('gameFilter');
    if (!gameSelect) return;

    const previousValue = gameSelect.value;
    const games = PokerTracker.DataStore.getAllGames();
    const sessions = PokerTracker.DataStore.getSessions();
    const hasUngroupedSessions = sessions.some(session => !session.gameId);

    const options = [];

    games
      .slice()
      .sort((a, b) => a.name.localeCompare(b.name))
      .forEach(game => {
        options.push({
          text: game.name,
          value: game.id
        });
      });

    if (hasUngroupedSessions) {
      options.push({ text: 'No Game', value: '__no_game__' });
    }

    if (PokerTracker?.Dropdowns) {
      PokerTracker.Dropdowns.setOptions('gameFilter', options, previousValue || null);
    } else {
      gameSelect.innerHTML = '';

      const blankOption = document.createElement('option');
      blankOption.value = '';
      blankOption.textContent = '';
      blankOption.selected = !previousValue;
      gameSelect.appendChild(blankOption);

      options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.text;
        if (option.value === previousValue) {
          opt.selected = true;
        }
        gameSelect.appendChild(opt);
      });
    }
  }

  function getFilteredSessions() {
    const nameFilter = document.getElementById('sessionSearch').value.trim().toLowerCase();
    const gameFilter = document.getElementById('gameFilter').value;
    const dateFrom = document.getElementById('dateFrom').value;
    const dateTo = document.getElementById('dateTo').value;
    const profitFilter = document.getElementById('profitFilter').value;

    const sessions = PokerTracker.DataStore.getSessions();
    const games = PokerTracker.DataStore.getAllGames();
    const gamesById = {};
    games.forEach(game => { gamesById[game.id] = game; });

    return sessions.filter(session => {
      const game = gamesById[session.gameId] || null;
      const sessionDate = PokerTracker.DataStore.getSessionDate(session);

      if (nameFilter) {
        const sessionName = (session.name || '').toLowerCase();
        const gameName = (game?.name || '').toLowerCase();
        if (!sessionName.includes(nameFilter) && !gameName.includes(nameFilter)) {
          return false;
        }
      }

      if (gameFilter) {
        if (gameFilter === '__no_game__') {
          if (session.gameId) return false;
        } else if (session.gameId !== gameFilter) {
          return false;
        }
      }

      if (dateFrom && (!sessionDate || sessionDate < dateFrom)) {
        return false;
      }

      if (dateTo && (!sessionDate || sessionDate > dateTo)) {
        return false;
      }

      const profit = (session.cashOut || 0) - (session.buyIn || 0);
      if (profitFilter === 'positive' && profit <= 0) {
        return false;
      }
      if (profitFilter === 'negative' && profit >= 0) {
        return false;
      }

      return true;
    });
  }

  function applyFilters() {
    const filteredSessions = getFilteredSessions();
    renderSessions(filteredSessions);
  }

  function viewSession(sessionId) {
    const sessionRoute = (PokerTracker.routes && PokerTracker.routes.session) || `{{ site.baseurl }}{% link projects/poker_tracker/session.html %}`;
    window.location.href = `${sessionRoute}?session_id=${sessionId}`;
  }

  function editSession(sessionId) {
    PokerTracker.SessionModal.showSessionSettingsModal(sessionId);
  }

  function goToActiveSession() {
    const activeSession = PokerTracker.DataStore.getActiveSession();
    if (activeSession) {
      const sessionRoute = (PokerTracker.routes && PokerTracker.routes.session) || `{{ site.baseurl }}{% link projects/poker_tracker/session.html %}`;
      window.location.href = `${sessionRoute}?session_id=${activeSession.id}`;
    }
  }

  function checkActiveSession() {
    if (typeof PokerTracker === 'undefined' || !PokerTracker.DataStore) return;

    const activeSession = PokerTracker.DataStore.getActiveSession();
    const liveSessionBtn = document.getElementById('liveSessionBtn');
    if (!liveSessionBtn) return;

    if (activeSession) {
      liveSessionBtn.className = 'btn btn-live-active';
      liveSessionBtn.disabled = false;
      liveSessionBtn.textContent = 'Live';
      liveSessionBtn.title = 'Go to live session';
    } else {
      liveSessionBtn.className = 'btn btn-live-disabled';
      liveSessionBtn.disabled = true;
      liveSessionBtn.textContent = 'Live';
      liveSessionBtn.title = 'No live session in progress';
    }
  }
</script>

<!-- Shared JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/slim-select@2/dist/slimselect.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="assets/js/data-store.js"></script>
<script src="assets/js/app.js"></script>

<script>
  function quickAction() {
    console.error('Quick Action - Could start new session, add hand, or quick access menu');
  }


  function showActionMenu(button, sessionId) {
    console.log('showActionMenu called', sessionId);
    const menu = document.getElementById('actionMenu');

    if (!menu) {
      console.error('Menu element not found');
      return;
    }

    // Check if menu is already open for the same session
    if (menu.classList.contains('show') && menu.dataset.sessionId === sessionId) {
      console.log('Menu already open for this session, hiding it');
      hideActionMenu();
      return;
    }

    // Close any existing menu first
    menu.classList.remove('show');

    menu.dataset.sessionId = sessionId; // Track which session this menu is for

    // Position menu above the button
    const buttonRect = button.getBoundingClientRect();
    console.log('Button rect:', buttonRect);
    console.log('Window size:', window.innerWidth, window.innerHeight);

    // Reset any previous styles
    menu.style.position = 'fixed';
    menu.style.top = 'auto';
    menu.style.right = 'auto';
    menu.style.bottom = 'auto';
    menu.style.transform = 'none';

    // Calculate position above the button
    const menuHeight = 140; // Approximate height of menu with 3 items
    const spaceAbove = buttonRect.top;
    const spaceBelow = window.innerHeight - buttonRect.bottom;

    if (spaceAbove >= menuHeight + 8) {
      // Position above button
      menu.style.bottom = (window.innerHeight - buttonRect.top + 8) + 'px';
      console.log('Positioning above, bottom:', menu.style.bottom);
    } else {
      // Position below button if not enough space above
      menu.style.top = (buttonRect.bottom + 8) + 'px';
      console.log('Positioning below, top:', menu.style.top);
    }

    // Horizontal positioning - keep menu within viewport
    let leftPos = buttonRect.left - 60;
    const menuWidth = 140;

    // Ensure menu doesn't go off the right edge
    if (leftPos + menuWidth > window.innerWidth - 16) {
      leftPos = window.innerWidth - menuWidth - 16;
    }

    // Ensure menu doesn't go off the left edge
    if (leftPos < 16) {
      leftPos = 16;
    }

    menu.style.left = leftPos + 'px';
    console.log('Final position - left:', leftPos, 'menu width:', menuWidth);

    // Update menu HTML with current session ID
    menu.innerHTML = `
      <button class="action-menu-item" onclick="executeAction('view', '${sessionId}')">
        <span>View</span>
      </button>
      <button class="action-menu-item" onclick="executeAction('edit', '${sessionId}')">
        <span>Edit</span>
      </button>
      <button class="action-menu-item delete" onclick="executeAction('delete', '${sessionId}')">
        <span>Delete</span>
      </button>
    `;

    // Show the menu
    menu.classList.add('show');
    console.log('Menu should be visible now, has show class:', menu.classList.contains('show'));
  }

  function hideActionMenu() {
    console.log("hide action menu called")
    const menu = document.getElementById('actionMenu');

    menu.classList.remove('show');
    delete menu.dataset.sessionId; // Clear the session ID
  }

  function executeAction(action, sessionId) {
    console.log('executeAction called with:', action, 'sessionId:', sessionId);

    if (!sessionId) {
      console.error('No session ID provided');
      return;
    }

    hideActionMenu();

    switch(action) {
      case 'view':
        console.log('Calling viewSession with:', sessionId);
        viewSession(sessionId);
        break;
      case 'edit':
        console.log('Calling editSession with:', sessionId);
        editSession(sessionId);
        break;
      case 'delete':
        console.log('Calling deleteSession with:', sessionId);
        deleteSession(sessionId);
        break;
    }
  }

  // Close action menu when clicking outside
  document.addEventListener('click', function(e) {
    console.log("clicked outside")

    if (!e.target.closest('.session-actions') && !e.target.closest('.action-menu-popup')) {
      hideActionMenu();
    }
  });

</script>

{% include_relative components/new-session-modal.html %}
{% include_relative components/new-game-modal.html %}
{% include_relative components/session-settings-modal.html %}

<!-- Action Menu -->
<div id="actionMenu" class="action-menu-popup">
  <!-- Menu items are dynamically generated with session ID -->
</div>

    </div>
  </main>
</body>
</html>
