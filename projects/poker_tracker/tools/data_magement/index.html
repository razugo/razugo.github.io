---
title: PokerTracker - Data Management
nav_id: tools
---

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>{{ page.title | default: "PokerTracker" }}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/slim-select@2/dist/slimselect.min.css">
  <link rel="stylesheet" href="{{ '/projects/poker_tracker/assets/styles/main.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/projects/poker_tracker/assets/styles/nav-bar.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/projects/poker_tracker/assets/styles/datetime-picker.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/projects/poker_tracker/assets/styles/new-session-modal.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/projects/poker_tracker/assets/styles/session-settings-modal.css' | relative_url }}">
</head>
<body>
  <div class="nav-container" data-component="nav-bar" data-active="{{ page.nav_id | default: '' }}" data-base="{{ '/projects/poker_tracker' | relative_url }}">
  <nav class="nav">
    <a href="{{ '/projects/poker_tracker/' | relative_url }}" class="nav-brand">PokerTracker</a>
    <ul class="nav-menu">
      <li><a href="#" class="nav-link live-session-btn">Live Session</a></li>
      <li><a href="{{ '/projects/poker_tracker/' | relative_url }}" class="nav-link{% if page.nav_id == 'dashboard' %} active{% endif %}" data-nav-id="dashboard">Dashboard</a></li>
      <li><a href="{{ '/projects/poker_tracker/bankroll/' | relative_url }}" class="nav-link{% if page.nav_id == 'bankroll' %} active{% endif %}" data-nav-id="bankroll">Bankroll</a></li>
      <li><a href="{{ '/projects/poker_tracker/sessions/' | relative_url }}" class="nav-link{% if page.nav_id == 'sessions' %} active{% endif %}" data-nav-id="sessions">Sessions</a></li>
      <li><a href="{{ '/projects/poker_tracker/tools/' | relative_url }}" class="nav-link{% if page.nav_id == 'tools' %} active{% endif %}" data-nav-id="tools">Tools</a></li>
    </ul>
    <button class="nav-toggle" aria-label="Toggle navigation">☰</button>
  </nav>
</div>

  <main>
    <div class="container">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
        <div>
          <h1>Data Management</h1>
          <p style="color: var(--text-secondary);">Import Poker Clicker session exports into PokerTracker</p>
        </div>
        <button class="btn btn-outline" onclick="goBackToTools()">←</button>
      </div>

      <div class="card">
        <div class="card-header">
          <h3 class="card-title">Import from Poker Clicker</h3>
        </div>
        <div class="card-content" style="display: flex; flex-direction: column; gap: 1.5rem;">
          <p style="color: var(--text-secondary);">Choose a Poker Clicker export file (<code>.json</code>) and PokerTracker will import the sessions directly into local storage. An alert will confirm how many sessions were added.</p>

          <div class="data-import" data-component="poker-import">
            <input type="file" id="pokerClickerFileInput" accept="application/json" style="display: none;" />
            <button class="btn" data-action="trigger-import">Select export file</button>
            <div class="import-status" data-status="idle" style="color: var(--text-secondary); font-size: 0.9rem;"></div>
          </div>
        </div>
      </div>

      <div style="margin: 3rem 0;"></div>

      <div class="card">
        <div class="card-header">
          <h3 class="card-title">PokerTracker Backup</h3>
        </div>
        <div class="card-content" style="display: flex; flex-direction: column; gap: 1.5rem;">
          <p style="color: var(--text-secondary);">Export your PokerTracker sessions to a backup file or restore from a previous export.</p>

          <div class="data-backup" data-component="poker-backup">
            <div class="backup-actions" style="display: flex; flex-wrap: wrap; gap: 0.75rem;">
              <button class="btn" data-action="export-backup">Download Data</button>
              <button class="btn btn-outline" data-action="import-backup">Import Backup</button>
            </div>
            <input type="file" id="pokerTrackerBackupFileInput" accept="application/json" style="display: none;" />
            <div class="backup-status" style="color: var(--text-secondary); font-size: 0.9rem;"></div>
          </div>
        </div>
      </div>

      <div style="margin: 3rem 0;"></div>

      <div class="card">
        <div class="card-header">
          <h3 class="card-title">Clear All Data</h3>
        </div>
        <div class="card-content" style="display: flex; flex-direction: column; gap: 1.5rem;">
          <p style="color: var(--text-secondary);">Permanently delete all PokerTracker data including sessions, statistics, and settings. This action cannot be undone.</p>

          <div class="data-clear" data-component="poker-clear">
            <button class="btn btn-danger" data-action="clear-all-data">Clear All Data</button>
            <div class="clear-status" style="color: var(--text-secondary); font-size: 0.9rem;"></div>
          </div>
        </div>
      </div>
    </div>
  </main>

<div data-component="new-session-modal"></div>
<div data-component="session-settings-modal"></div>

<script src="https://cdn.jsdelivr.net/npm/slim-select@2/dist/slimselect.min.js"></script>
<script src="{{ '/projects/poker_tracker/assets/js/data-store.js' | relative_url }}"></script>
<script src="{{ '/projects/poker_tracker/assets/js/app.js' | relative_url }}"></script>
<script src="{{ '/projects/poker_tracker/assets/js/datetime-picker.js' | relative_url }}"></script>
<script src="{{ '/projects/poker_tracker/assets/js/nav-bar.js' | relative_url }}"></script>
<script src="{{ '/projects/poker_tracker/assets/js/new-session-modal.js' | relative_url }}"></script>
<script src="{{ '/projects/poker_tracker/assets/js/session-settings-modal.js' | relative_url }}"></script>

<script>
  (function() {
    const createStatusUpdater = statusElement => message => {
      if (statusElement) {
        statusElement.textContent = message || '';
      }
    };

    // Shared merge function for both import types
    const mergeSessions = importedSessions => {
      const existingSessions = Array.isArray(PokerTracker.DataStore.sessions)
        ? PokerTracker.DataStore.sessions
        : [];

      const mergedMap = new Map();

      // Add existing sessions to map (ensure they're PokerSession instances)
      existingSessions.forEach(session => {
        if (session && session.id) {
          // Convert to PokerSession if needed
          if (!(session instanceof PokerTracker.PokerSession)) {
            try {
              session = new PokerTracker.PokerSession(session);
            } catch (err) {
              console.warn('Failed to convert existing session to PokerSession:', err, session);
              return;
            }
          }
          mergedMap.set(session.id, session);
        }
      });

      let newCount = 0;
      let skippedCount = 0;
      importedSessions.forEach(session => {
        if (!session || !session.id) return;
        if (!mergedMap.has(session.id)) {
          // Only add sessions that don't already exist (they're already PokerSession instances)
          mergedMap.set(session.id, session);
          newCount++;
        } else {
          // Count sessions that already exist (duplicates)
          skippedCount++;
        }
      });

      const mergedSessions = Array.from(mergedMap.values());
      PokerTracker.DataStore.sessions = mergedSessions;
      PokerTracker.DataStore.appState = { liveSessionId: null, liveSessionStart: null };
      PokerTracker.DataStore.notifyLiveSessionChange(null);

      // Notify all pages that session data has changed
      if (typeof PokerTracker.DataStore.notifySessionDataChange === 'function') {
        PokerTracker.DataStore.notifySessionDataChange(null);
      }

      return { newCount, skippedCount };
    };

    const importComponent = document.querySelector('[data-component="poker-import"]');
    if (importComponent) {
      const trigger = importComponent.querySelector('[data-action="trigger-import"]');
      const fileInput = document.getElementById('pokerClickerFileInput');
      const statusElement = importComponent.querySelector('.import-status');
      const updateStatus = createStatusUpdater(statusElement);

      if (trigger && fileInput) {
        const coerceMoney = value => {
          if (value === null || typeof value === 'undefined' || value === '') return 0;
          const numeric = typeof value === 'number' ? value : parseFloat(value);
          if (!Number.isFinite(numeric)) return 0;
          return Math.round(numeric * 100) / 100;
        };

        const coerceMoneyOrNull = value => {
          if (value === null || typeof value === 'undefined' || value === '') return null;
          const numeric = typeof value === 'number' ? value : parseFloat(value);
          if (!Number.isFinite(numeric)) return null;
          return Math.round(numeric * 100) / 100;
        };

        const parseDateString = value => {
          if (!value || typeof value !== 'string') return null;
          const parsed = new Date(value);
          if (Number.isNaN(parsed.getTime())) return null;
          return parsed;
        };

        const toISODate = value => {
          const parsed = parseDateString(value);
          if (!parsed) return null;
          return parsed.toISOString().split('T')[0];
        };

        const toISODateTime = value => {
          const parsed = parseDateString(value);
          if (!parsed) return null;
          return parsed.toISOString();
        };

        const computeDuration = (startValue, endValue) => {
          const start = parseDateString(startValue);
          const end = parseDateString(endValue);
          if (!start || !end || end <= start) return null;
          const hours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);
          return Math.round(hours * 100) / 100;
        };

        const buildHandId = (sessionId, index, timestamp) => {
          const base = timestamp && Number.isFinite(timestamp) ? timestamp : Date.now();
          return `hand-${sessionId}-${index + 1}-${base}`;
        };

        const sanitizeCounts = (source, fallback) => {
          const result = {};
          if (source && typeof source === 'object') {
            Object.keys(source).forEach(key => {
              const numeric = typeof source[key] === 'number' ? source[key] : parseFloat(source[key]);
              if (Number.isFinite(numeric) && numeric > 0) {
                result[key] = numeric;
              }
            });
          }
          // Use fallback data computed from hands if source doesn't have counts
          if (Object.keys(result).length === 0 && fallback) {
            return { ...fallback };
          }
          return result;
        };

        const deriveCountsFromHands = (hands, playedOnly) => {
          return hands.reduce((acc, hand) => {
            if (!hand || !hand.key) return acc;
            if (playedOnly && !hand.played) return acc;
            acc[hand.key] = (acc[hand.key] || 0) + 1;
            return acc;
          }, {});
        };

        const convertHand = (sessionId, hand, index) => {
          if (!hand || typeof hand !== 'object') {
            return null;
          }
          const timestamp = typeof hand.timestamp === 'number' ? hand.timestamp : parseFloat(hand.timestamp);
          const position = typeof hand.position === 'number' ? hand.position : (index + 1);
          const entry = {
            id: buildHandId(sessionId, index, Number.isFinite(timestamp) ? timestamp : null),
            key: hand.key || '',
            timestamp: Number.isFinite(timestamp) ? timestamp : Date.now(),
            played: Boolean(hand.played),
            position: Number.isFinite(position) ? position : (index + 1),
            notes: hand.notes || ''
          };
          if (Object.prototype.hasOwnProperty.call(hand, 'outcome')) {
            entry.outcome = hand.outcome;
          }
          if (Object.prototype.hasOwnProperty.call(hand, 'pot')) {
            entry.pot = hand.pot;
          }
          return entry;
        };

        const convertSession = raw => {
          if (!raw || typeof raw !== 'object') return null;

          const sessionId = raw.id || `session-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
          const hands = Array.isArray(raw.hands) ? raw.hands : [];
          const handHistory = hands
            .map((hand, index) => convertHand(sessionId, hand, index))
            .filter(Boolean);

          const generatedCounts = deriveCountsFromHands(handHistory, false);
          const generatedPlayedCounts = deriveCountsFromHands(handHistory, true);

          const counts = sanitizeCounts(raw.counts, generatedCounts);
          const playedCounts = sanitizeCounts(raw.playedCounts, generatedPlayedCounts);

          // Compute total hands from hand history if not provided, otherwise use 0
          const numericTotal = typeof raw.total === 'number' ? raw.total : parseInt(raw.total, 10);
          const totalHands = Number.isFinite(numericTotal) ? numericTotal : handHistory.length;

          // Compute total played from hand history if not provided, otherwise use 0
          const numericTotalPlayed = typeof raw.totalPlayed === 'number' ? raw.totalPlayed : parseInt(raw.totalPlayed, 10);
          const totalPlayed = Number.isFinite(numericTotalPlayed) ? numericTotalPlayed : handHistory.filter(hand => hand.played).length;

          // Compute VPIP from totals if not provided
          const rawVpip = typeof raw.vpip === 'number' ? raw.vpip : parseFloat(raw.vpip);
          const vpipValue = Number.isFinite(rawVpip) ? rawVpip : (totalHands > 0 ? ((totalPlayed / totalHands) * 100) : 0);

          const sessionDate = raw.sessionDate || null;
          const trimmedLocation = typeof raw.location === 'string' && raw.location.trim() ? raw.location.trim() : null;
          const startTime = raw.startTime ? toISODateTime(raw.startTime) : null;
          const endTime = raw.endTime ? toISODateTime(raw.endTime) : null;

          // Create PokerSession data object (removing deprecated fields like name, durationHours)
          const sessionData = {
            id: sessionId,
            location: trimmedLocation,
            smallBlind: raw.smallBlind ? coerceMoneyOrNull(raw.smallBlind) : null,
            bigBlind: raw.bigBlind ? coerceMoneyOrNull(raw.bigBlind) : null,
            startTime: startTime,
            endTime: endTime,
            buyIn: coerceMoney(raw.buyIn),
            cashOut: coerceMoney(raw.cashOut),
            sessionDate: sessionDate,
            counts: counts,
            playedCounts: playedCounts,
            handHistory: handHistory,
            total: totalHands,
            totalPlayed: totalPlayed,
            vpip: Math.max(0, Math.min(100, Math.round((vpipValue || 0) * 10) / 10)),
            notes: raw.notes || ''
          };

          // Create PokerSession instance which will validate and normalize the data
          try {
            return new PokerTracker.PokerSession(sessionData);
          } catch (err) {
            console.warn('Failed to create PokerSession from imported data:', err, sessionData);
            return null;
          }
        };

        const parseExport = contents => {
          let parsed;
          try {
            parsed = JSON.parse(contents);
          } catch (err) {
            throw new Error('File is not valid JSON.');
          }

          if (!parsed || !parsed.sessions) {
            throw new Error('Export missing sessions payload.');
          }

          let sessionsBlob = parsed.sessions;
          if (typeof sessionsBlob === 'string') {
            try {
              sessionsBlob = JSON.parse(sessionsBlob);
            } catch (err) {
              throw new Error('Session payload is not valid JSON.');
            }
          }

          if (!sessionsBlob || typeof sessionsBlob !== 'object') {
            throw new Error('Session payload is not an object.');
          }

          const converted = Object.values(sessionsBlob)
            .map(convertSession)
            .filter(Boolean);

          if (converted.length === 0) {
            throw new Error('No sessions found to import.');
          }

          return converted;
        };


        const handleFileSelection = () => {
          const file = fileInput.files && fileInput.files[0];
          if (!file) return;

          const fileName = file && file.name ? file.name : 'export.json';

          trigger.disabled = true;
          updateStatus(`Importing "${fileName}"...`);

          const reader = new FileReader();
          reader.onload = event => {
            try {
              const importedSessions = parseExport(event.target.result);
              const result = mergeSessions(importedSessions);
              const { newCount, skippedCount } = result;

              let message = `${newCount} session${newCount === 1 ? '' : 's'} imported.`;
              if (skippedCount > 0) {
                message += ` ${skippedCount} duplicate${skippedCount === 1 ? '' : 's'} skipped.`;
              }
              alert(message);
              updateStatus('Import complete. You can import another file if needed.');
            } catch (err) {
              console.error(err);
              alert(err.message || 'Import failed.');
              updateStatus('');
            } finally {
              trigger.disabled = false;
              fileInput.value = '';
            }
          };
          reader.onerror = () => {
            alert('Failed to read file.');
            trigger.disabled = false;
            updateStatus('');
            fileInput.value = '';
          };
          reader.readAsText(file);
        };

        trigger.addEventListener('click', () => {
          if (trigger.disabled) return;
          fileInput.click();
        });

        fileInput.addEventListener('change', handleFileSelection);
      }
    }

    const backupComponent = document.querySelector('[data-component="poker-backup"]');
    if (backupComponent) {
      const exportButton = backupComponent.querySelector('[data-action="export-backup"]');
      const importButton = backupComponent.querySelector('[data-action="import-backup"]');
      const fileInput = document.getElementById('pokerTrackerBackupFileInput');
      const statusElement = backupComponent.querySelector('.backup-status');
      const updateBackupStatus = createStatusUpdater(statusElement);

      const safeArray = value => (Array.isArray(value) ? value : []);

      const buildBackupPayload = () => {
        if (!window.PokerTracker || !PokerTracker.DataStore) {
          throw new Error('PokerTracker data store is not available.');
        }

        const dataStore = PokerTracker.DataStore;
        const sessions = dataStore.getSessions ? dataStore.getSessions() : safeArray(dataStore.sessions);

        // Convert PokerSession instances to plain objects for export
        const plainSessions = sessions.map(session => {
          if (session instanceof PokerTracker.PokerSession) {
            return session.toJSON();
          }
          return session;
        });

        return {
          version: 'pokertracker.backup.v1',
          exportedAt: new Date().toISOString(),
          sessions: safeArray(plainSessions)
        };
      };

      const downloadBackup = payload => {
        const timestamp = new Date().toISOString().replace(/[:]/g, '-');
        const filename = `pokertracker-backup-${timestamp}.json`;
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = filename;
        document.body.appendChild(anchor);
        anchor.click();
        setTimeout(() => {
          document.body.removeChild(anchor);
          URL.revokeObjectURL(url);
        }, 0);
      };

      const parseBackup = contents => {
        let parsed;
        try {
          parsed = JSON.parse(contents);
        } catch (err) {
          throw new Error('File is not valid JSON.');
        }

        if (!parsed || !Array.isArray(parsed.sessions)) {
          throw new Error('Backup must include a sessions array.');
        }

        return {
          sessions: safeArray(parsed.sessions)
        };
      };

      const applyBackup = backup => {
        if (!window.PokerTracker || !PokerTracker.DataStore) {
          throw new Error('PokerTracker data store is not available.');
        }

        // Convert raw session data to PokerSession instances, filtering out invalid sessions
        const rawSessions = safeArray(backup.sessions);
        const validatedSessions = rawSessions
          .map(sessionData => {
            try {
              // Create PokerSession instance which will validate and normalize the data
              // This automatically discards any extra fields not recognized by PokerSession
              return new PokerTracker.PokerSession(sessionData);
            } catch (err) {
              console.warn('Failed to create PokerSession from backup data:', err, sessionData);
              return null;
            }
          })
          .filter(Boolean);

        if (validatedSessions.length === 0) {
          throw new Error('No valid sessions found in backup.');
        }

        // Use the same merge logic as the Poker Clicker import
        const result = mergeSessions(validatedSessions);
        return result;
      };

      if (exportButton) {
        exportButton.addEventListener('click', () => {
          try {
            updateBackupStatus('Preparing export...');
            const payload = buildBackupPayload();
            downloadBackup(payload);
            const sessionCount = payload.sessions.length;
            updateBackupStatus(`Export complete. Saved ${sessionCount} session${sessionCount === 1 ? '' : 's'}.`);
          } catch (err) {
            console.error(err);
            alert(err.message || 'Export failed.');
            updateBackupStatus('');
          }
        });
      }

      if (importButton && fileInput) {
        const handleBackupImport = () => {
          const file = fileInput.files && fileInput.files[0];
          if (!file) return;

          const fileName = file.name || 'backup.json';

          importButton.disabled = true;
          if (exportButton) exportButton.disabled = true;
          updateBackupStatus(`Importing "${fileName}"...`);

          const reader = new FileReader();
          reader.onload = event => {
            try {
              const backup = parseBackup(event.target.result);
              const result = applyBackup(backup);
              const { newCount, skippedCount } = result;

              let message = `${newCount} session${newCount === 1 ? '' : 's'} imported from backup.`;
              if (skippedCount > 0) {
                message += ` ${skippedCount} duplicate${skippedCount === 1 ? '' : 's'} skipped.`;
              }
              alert(message);
              updateBackupStatus('Import complete. Your data is saved locally.');
            } catch (err) {
              console.error(err);
              alert(err.message || 'Import failed.');
              updateBackupStatus('');
            } finally {
              importButton.disabled = false;
              if (exportButton) exportButton.disabled = false;
              fileInput.value = '';
            }
          };
          reader.onerror = () => {
            alert('Failed to read file.');
            importButton.disabled = false;
            if (exportButton) exportButton.disabled = false;
            updateBackupStatus('');
            fileInput.value = '';
          };
          reader.readAsText(file);
        };

        importButton.addEventListener('click', () => {
          if (importButton.disabled) return;
          fileInput.click();
        });

        fileInput.addEventListener('change', handleBackupImport);
      }
    }

    // Clear All Data Component
    const clearComponent = document.querySelector('[data-component="poker-clear"]');
    if (clearComponent) {
      const clearButton = clearComponent.querySelector('[data-action="clear-all-data"]');
      const statusElement = clearComponent.querySelector('.clear-status');
      const updateClearStatus = createStatusUpdater(statusElement);

      if (clearButton) {
        clearButton.addEventListener('click', () => {
          if (clearButton.disabled) return;

          // First confirmation dialog
          const firstConfirmation = confirm(
            'This will permanently delete ALL PokerTracker data including sessions, statistics, and settings.\n\n' +
            'This action CANNOT be undone.\n\n' +
            'Are you sure you want to continue?'
          );

          if (!firstConfirmation) {
            updateClearStatus('Data clearing cancelled.');
            return;
          }

          // Second confirmation dialog
          const secondConfirmation = confirm(
            'FINAL WARNING: You are about to delete ALL your poker data.\n\n' +
            'All sessions, hand histories, and statistics will be permanently lost.\n\n' +
            'Click OK to proceed with deletion, or Cancel to keep your data.'
          );

          if (!secondConfirmation) {
            updateClearStatus('Data clearing cancelled.');
            return;
          }

          // Proceed with deletion
          try {
            clearButton.disabled = true;
            updateClearStatus('Clearing all data...');

            if (!window.PokerTracker || !PokerTracker.DataStore) {
              throw new Error('PokerTracker data store is not available.');
            }

            // Call the clearAllData function
            const success = PokerTracker.DataStore.clearAllData();

            if (success) {
              alert('All PokerTracker data has been permanently deleted.');
              updateClearStatus('All data cleared successfully.');
            } else {
              throw new Error('Failed to clear data.');
            }
          } catch (err) {
            console.error('Error clearing data:', err);
            alert(err.message || 'Failed to clear data.');
            updateClearStatus('Error occurred while clearing data.');
          } finally {
            clearButton.disabled = false;
          }
        });
      }
    }
  })();

  function goBackToTools() {
    window.location.href = '/projects/poker_tracker/tools/';
  }
</script>
</body>
</html>
