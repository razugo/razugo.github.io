---
title: PokerTracker - Session
nav_id: session
---

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>{{ page.title | default: "PokerTracker" }}</title>
  <link rel="stylesheet" href="styles/main.css">
</head>
<body>
  {% include_relative components/nav-bar.html %}

  <main>
    <!-- Live Stats Bar (always visible) -->
<div class="live-stats-bar" id="liveStatsBar">
  <div class="live-stats-content">
    <div class="stat-group stat-session">
      <span class="stat-label">Session</span>
      <span class="stat-value session-name" id="sessionNameStat">Unnamed Session</span>
    </div>
    <div class="stat-group">
      <span class="stat-label">VPIP</span>
      <span class="stat-value" id="vpipStat">0% (0/0)</span>
    </div>
    <div class="stat-group">
      <span class="stat-label">P&L</span>
      <span class="stat-value" id="profitStat">$0</span>
    </div>
  </div>
  <button class="live-stats-toggle" onclick="showSessionSettingsModal()">✏️</button>
</div>


<!-- Main Content with View Tabs -->
<div class="container" style="padding-top: 1.5rem;">
  <!-- View Tabs -->
  <div id="view-tabs">
    <button id="grid-tab" class="view-tab active">Grid</button>
    <button id="list-tab" class="view-tab">List</button>
  </div>

  <!-- Grid Container -->
  <div id="grid-container">
    <div id="grid" aria-label="13 by 13 poker starting-hand grid"></div>

    <div id="toggle-controls">
      <label class="toggle-container">
        <input type="checkbox" id="toggleCounts" class="toggle-input">
        <span class="toggle-slider"></span>
        <span class="toggle-label">Counts</span>
      </label>
      <label class="toggle-container">
        <input type="checkbox" id="togglePlayed" class="toggle-input">
        <span class="toggle-slider"></span>
        <span class="toggle-label">Played</span>
      </label>
      <button id="undo">Undo</button>
    </div>

    <div class="note">Quick tap: dealt (folded). Long press (>600ms): dealt AND played.</div>
  </div>

  <!-- List Container -->
  <div id="list-container">
    <!-- List items will be dynamically generated -->
  </div>
</div>

<!-- Magnify overlay for mobile -->
<div id="magnify-overlay"></div>

<script>

  let currentSessionId = null;
  let currentView = 'grid';
  let showCounts = false;
  let showPlayed = false;

  function syncToggleState() {
    const countsToggle = document.getElementById('toggleCounts');
    const playedToggle = document.getElementById('togglePlayed');
    if (countsToggle) countsToggle.checked = showCounts;
    if (playedToggle) playedToggle.checked = showPlayed;
  }

  // Interaction state
  let activeCell = null;
  let isMouseDown = false;
  let longPressTimer = null;

  // Elements
  const grid = document.getElementById('grid');
  const gridTab = document.getElementById('grid-tab');
  const listTab = document.getElementById('list-tab');
  const gridContainer = document.getElementById('grid-container');
  const listContainer = document.getElementById('list-container');
  const magnifyOverlay = document.getElementById('magnify-overlay');

  // Get session ID from URL parameters
  function getSessionIdFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('session_id');
  }

  function toggleSessionOverlay() {
    document.getElementById('sessionOverlay').classList.toggle('expanded');
  }

  function getCurrentSession() {
    if (!currentSessionId) return null;
    return PokerTracker.DataStore.getSession(currentSessionId);
  }

  function getSessionData() {
    if (!currentSessionId) {
      console.error('getSessionData: No currentSessionId');
      return null;
    }
    const data = PokerTracker.DataStore.getSessionData(currentSessionId);
    console.log('getSessionData result:', data);
    return data;
  }

  function updateSessionStats() {
    if (!currentSessionId) {
      console.error('updateSessionStats: No currentSessionId');
      return;
    }

    console.log('updateSessionStats: Getting session data for ID:', currentSessionId);
    const sessionData = getSessionData();

    if (!sessionData) {
      console.error('updateSessionStats: No session data returned');
      return;
    }
    const session = getCurrentSession();

    if (!session || !sessionData) return;

    const game = PokerTracker.DataStore.getGame(session.gameId);
    const vpipPercent = sessionData.vpip.toFixed(1);
    const profit = (session.cashOut || 0) - (session.buyIn || 0);

    // Update live stats bar
    const sessionName = session.name || (game ? game.name : 'Unnamed Session');
    document.getElementById('sessionNameStat').textContent = sessionName;

    document.getElementById('vpipStat').textContent = `${vpipPercent}% (${sessionData.totalPlayed}/${sessionData.total})`;

    const profitElement = document.getElementById('profitStat');
    profitElement.textContent = `${profit >= 0 ? '+' : ''}$${profit}`;
    profitElement.className = 'stat-value ' + (profit >= 0 ? 'positive' : 'negative');



  }

  function keyFor(i, j) {
    const ranks = ['A','K','Q','J','T','9','8','7','6','5','4','3','2'];
    if (i === j) {
      return ranks[i] + ranks[i];
    } else if (i < j) {
      return ranks[i] + ranks[j] + 's';
    } else {
      return ranks[j] + ranks[i] + 'o';
    }
  }

  function buildGrid() {
    grid.innerHTML = '';
    for (let i = 0; i < 13; i++) {
      for (let j = 0; j < 13; j++) {
        const key = keyFor(i, j);
        const cell = document.createElement('button');
        cell.type = 'button';
        cell.className = 'cell' + (i === j ? ' pair' : '');
        cell.dataset.key = key;
        cell.textContent = key;
        grid.appendChild(cell);
      }
    }
    render();
    fitGridToViewport();
  }

  function updateCellColors() {
    const sessionData = getSessionData();
    if (!sessionData) return;

    const cells = grid.children;
    const sourceData = showPlayed ? sessionData.playedCounts : sessionData.counts;
    const values = Object.values(sourceData);
    const max = Math.max(1, ...values);

    for (const cell of cells) {
      const key = cell.dataset.key;
      const c = sourceData[key] || 0;

      let baseColor;
      if (key.endsWith('s')) { // Suited
        baseColor = '#D8D8D8';
      } else if (key.length === 2) { // Pair
        baseColor = '#A9A9A9';
      } else { // Off-suit
        baseColor = '#FFFFFF';
      }

      if (c > 0) {
        const ratio = c / max;
        const r = 255;
        const g = Math.round(255 * (1 - ratio));
        const b = Math.round(255 * (1 - ratio));
        cell.style.backgroundColor = `rgb(${r},${g},${b})`;
        const luminance = 0.2126*r + 0.7152*g + 0.0722*b;
        cell.style.color = luminance < 128 ? '#ffffff' : '#2d3748';
      } else {
        cell.style.backgroundColor = baseColor;
        cell.style.color = '#2d3748';
      }
    }
  }

  function render() {
    const sessionData = getSessionData();
    if (!sessionData) {
      // Clear grid when no session selected
      for (const cell of grid.children) {
        const key = cell.dataset.key;
        cell.textContent = key;
        cell.classList.remove('played');
        cell.style.backgroundColor = '';
        cell.style.color = '';
      }
      return;
    }

    for (const cell of grid.children) {
      const key = cell.dataset.key;
      const playedCount = sessionData.playedCounts[key] || 0;
      const totalCount = sessionData.counts[key] || 0;

      if (showCounts) {
        cell.textContent = showPlayed ? playedCount : totalCount;
      } else {
        cell.textContent = key;
      }

      cell.classList.toggle('played', playedCount > 0);
      cell.style.display = 'flex';
    }
    updateCellColors();
  }

  function updateMagnifyOverlay(cell, clientX, clientY) {
    const currentBg = magnifyOverlay.style.backgroundColor;

    magnifyOverlay.textContent = cell.textContent;

    const newClasses = ['cell'];
    if (cell.classList.contains('pair')) {
      newClasses.push('pair');
    }
    magnifyOverlay.className = newClasses.join(' ');
    magnifyOverlay.id = 'magnify-overlay';

    if (currentBg === '#e8f5e8' || currentBg === 'rgb(232, 245, 232)') {
      magnifyOverlay.style.backgroundColor = '#e8f5e8';
    } else {
      magnifyOverlay.style.backgroundColor = cell.style.backgroundColor || '';
    }
    magnifyOverlay.style.color = cell.style.color || '';

    if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
      const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
      const scaledSize = cellSize * 2.0;
      magnifyOverlay.style.left = (clientX - scaledSize / 2) + 'px';
      magnifyOverlay.style.top = (clientY - 40) + 'px';
    }
  }

  function showMagnifyOverlay(cell, clientX, clientY) {
    if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
      magnifyOverlay.style.display = 'flex';
      magnifyOverlay.style.backgroundColor = '';
      updateMagnifyOverlay(cell, clientX, clientY);
    }
  }

  function hideMagnifyOverlay() {
    magnifyOverlay.style.display = 'none';
  }

  function increment(key, played = false) {
    if (!currentSessionId) return;

    const sessionData = getSessionData();
    if (!sessionData) return;

    const handEntry = {
      id: Date.now().toString(),
      key: key,
      timestamp: Date.now(),
      played: played,
      position: sessionData.handHistory.length + 1,
      notes: ""
    };

    // Add to session data
    PokerTracker.DataStore.addHand(currentSessionId, key, played, handEntry.notes);

    updateSessionStats();
    render();

    if (currentView === 'list') {
      renderList();
    }
  }

  function renderList() {
    const sessionData = getSessionData();
    listContainer.innerHTML = '';

    if (!sessionData) return;

    const sortedHands = [...sessionData.handHistory].reverse();

    sortedHands.forEach((hand, index) => {
      const handIndex = sessionData.handHistory.length - 1 - index;
      const listItem = document.createElement('div');
      listItem.className = 'list-item';
      listItem.dataset.handIndex = handIndex;

      listItem.innerHTML = `
        <div class="list-item-hand">${hand.key}</div>
        <div class="list-item-position">#${hand.position}</div>
        <div class="list-item-actions">
          <button class="action-button notes-button" data-action="notes">Notes</button>
          <button class="toggle-switch ${hand.played ? 'played' : ''}" data-action="toggle"></button>
          <button class="delete-button" data-action="delete">🗑️</button>
        </div>
        <div class="list-item-notes-container ${hand.notes ? 'active' : ''}">
          <textarea class="list-item-notes" placeholder="Add notes...">${hand.notes || ''}</textarea>
        </div>
      `;

      const notesButton = listItem.querySelector('[data-action="notes"]');
      const notesContainer = listItem.querySelector('.list-item-notes-container');
      const toggleButton = listItem.querySelector('[data-action="toggle"]');
      const deleteButton = listItem.querySelector('[data-action="delete"]');
      const notesTextarea = listItem.querySelector('.list-item-notes');

      if (hand.notes && hand.notes.trim() !== '') {
        notesButton.classList.add('toggle-active');
      }

      notesButton.addEventListener('click', () => {
        notesContainer.classList.toggle('active');
        notesButton.classList.toggle('toggle-active');
      });

      toggleButton.addEventListener('click', () => {
        toggleHandStatus(handIndex);
      });

      deleteButton.addEventListener('click', () => {
        deleteHand(handIndex);
      });

      notesTextarea.addEventListener('input', () => {
        saveNotes(handIndex, notesTextarea.value);
      });

      listContainer.appendChild(listItem);
    });
  }

  function handleInteractionStart(e) {
    if (!getCurrentSession()) return;

    if (e.target.classList.contains('cell')) {
      isMouseDown = true;
      if (activeCell) {
        activeCell.classList.remove('active', 'playing');
      }
      activeCell = e.target;
      activeCell.classList.add('active');

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      showMagnifyOverlay(activeCell, clientX, clientY);

      longPressTimer = setTimeout(() => {
        if (isMouseDown && activeCell) {
          activeCell.classList.add('playing');
          magnifyOverlay.style.backgroundColor = '#e8f5e8';
          if (navigator.vibrate) {
            navigator.vibrate(50);
          }
        }
      }, 600);

      e.preventDefault();
    }
  }

  function handleInteractionMove(e) {
    if (isMouseDown) {
      let clientX, clientY;
      if (e.touches) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      if (window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
        const scaledSize = cellSize * 2.0;
        magnifyOverlay.style.left = (clientX - scaledSize / 2) + 'px';
        magnifyOverlay.style.top = (clientY - 40) + 'px';
      }

      const target = document.elementFromPoint(clientX, clientY);

      if (target && target.classList.contains('cell') && target !== activeCell) {
        clearTimeout(longPressTimer);

        if (activeCell) {
          activeCell.classList.remove('active', 'playing');
        }

        magnifyOverlay.style.backgroundColor = '';

        activeCell = target;
        activeCell.classList.add('active');

        updateMagnifyOverlay(activeCell, clientX, clientY);

        longPressTimer = setTimeout(() => {
          if (isMouseDown && activeCell) {
            activeCell.classList.add('playing');
            magnifyOverlay.style.backgroundColor = '#e8f5e8';
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
          }
        }, 600);
      }
      e.preventDefault();
    }
  }

  function handleInteractionEnd(e) {
    if (isMouseDown && activeCell) {
      let releaseTarget;
      if (e.touches && e.changedTouches && e.changedTouches.length > 0) {
        releaseTarget = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
      } else {
        releaseTarget = e.target;
      }

      const gridContainer = document.getElementById('grid');
      const isOverGrid = releaseTarget && (releaseTarget.classList.contains('cell') || gridContainer.contains(releaseTarget));

      if (isOverGrid) {
        const key = activeCell.dataset.key;
        const wasLongPress = activeCell.classList.contains('playing');

        clearTimeout(longPressTimer);
        increment(key, wasLongPress);
      } else {
        clearTimeout(longPressTimer);
      }

      activeCell.classList.remove('active', 'playing');
      activeCell = null;
    }

    hideMagnifyOverlay();
    isMouseDown = false;
    clearTimeout(longPressTimer);
  }

  function saveNotes(handIndex, notes) {
    const sessionData = getSessionData();
    if (!sessionData) return;

    const hand = sessionData.handHistory[handIndex];
    if (hand) {
      PokerTracker.DataStore.updateHandNotes(currentSessionId, hand.id, notes);
    }
  }

  function toggleHandStatus(handIndex) {
    const sessionData = getSessionData();
    if (!sessionData) return;

    const hand = sessionData.handHistory[handIndex];
    if (hand) {
      PokerTracker.DataStore.updateHandStatus(currentSessionId, hand.id, !hand.played);
      updateSessionStats();
      render();
      renderList();
    }
  }

  function deleteHand(handIndex) {
    const sessionData = getSessionData();
    if (!sessionData) return;

    const hand = sessionData.handHistory[handIndex];
    if (hand && confirm('Delete this hand?')) {
      PokerTracker.DataStore.deleteHand(currentSessionId, hand.id);
      updateSessionStats();
      render();
      renderList();
    }
  }

  function undo() {
    PokerTracker.DataStore.undoLastHand(currentSessionId);
    updateSessionStats();
    render();
    if (currentView === 'list') {
      renderList();
    }
  }

  function toggleCounts() {
    const checkbox = document.getElementById('toggleCounts');
    showCounts = checkbox.checked;
    render();
  }

  function togglePlayedFilter() {
    const checkbox = document.getElementById('togglePlayed');
    showPlayed = checkbox.checked;
    render();
  }

  function switchView(view) {
    currentView = view;

    // Hide all containers
    gridContainer.style.display = 'none';
    listContainer.classList.remove('active');

    // Remove active class from all tabs
    gridTab.classList.remove('active');
    listTab.classList.remove('active');

    // Show selected view
    if (view === 'grid') {
      gridContainer.style.display = 'flex';
      gridTab.classList.add('active');
    } else if (view === 'list') {
      listContainer.classList.add('active');
      listTab.classList.add('active');
      renderList();
    }
  }

  function fitGridToViewport() {
    const root = document.documentElement;
    const vw = document.documentElement.clientWidth;

    let chosenGap;
    if (vw < 768) chosenGap = 2;
    else chosenGap = 4;

    root.style.setProperty('--gap', chosenGap + 'px');

    let containerPadding, bodyPadding;
    if (vw < 480) {
      containerPadding = 24;
      bodyPadding = 0;
    } else {
      containerPadding = 40;
      bodyPadding = 40;
    }

    const gridWidth = vw - containerPadding - bodyPadding;
    const MAX_CELL = vw < 480 ? 30 : 56;
    const MIN_CELL = 18;
    const ideal = Math.floor((gridWidth - chosenGap * 12) / 13);
    const cell = Math.max(MIN_CELL, Math.min(MAX_CELL, ideal));
    root.style.setProperty('--cell', cell + 'px');
  }

  // Event Listeners and Initialization
  document.addEventListener('DOMContentLoaded', function() {
    currentSessionId = getSessionIdFromURL();
    console.log('Session ID from URL:', currentSessionId);

    if (!currentSessionId) {
      console.error('No session ID provided');
      window.location.href = '/projects/poker_tracker/sessions';
      return;
    }

    // Debug: Check all available sessions
    const allSessions = PokerTracker.DataStore.getSessions();
    console.log('All available sessions:', allSessions);
    console.log('Looking for session ID:', currentSessionId);

    const session = getCurrentSession();
    console.log('Found session:', session);

    if (!session) {
      console.error(`Session not found for ID: ${currentSessionId}`);
      window.location.href = '/projects/poker_tracker/sessions';
      return;
    }

    // Populate games dropdown (if it exists)
    const gameSelect = document.getElementById('gameSelect');
    if (gameSelect) {
      const games = PokerTracker.DataStore.getAllGames();
      console.log('Available games:', games);
      console.log('Session gameId:', session.gameId);

      games.forEach(game => {
        if (game && game.stakes) {
          const option = document.createElement('option');
          option.value = game.id;
          option.textContent = `${game.name} (${game.stakes.smallBlind}/${game.stakes.bigBlind})`;
          gameSelect.appendChild(option);
        }
      });
    } else {
      console.log('gameSelect element not found - skipping game dropdown population');
    }

    buildGrid();
    updateSessionStats();
    syncToggleState();

    // Setup interaction handlers
    grid.addEventListener('mousedown', handleInteractionStart);
    grid.addEventListener('mousemove', handleInteractionMove);
    document.addEventListener('mouseup', handleInteractionEnd);

    grid.addEventListener('touchstart', handleInteractionStart, { passive: false });
    grid.addEventListener('touchmove', handleInteractionMove, { passive: false });
    grid.addEventListener('touchend', handleInteractionEnd);

    // View tab handlers
    gridTab.addEventListener('click', () => switchView('grid'));
    listTab.addEventListener('click', () => switchView('list'));

    // Control button handlers
    document.getElementById('toggleCounts').addEventListener('change', toggleCounts);
    document.getElementById('togglePlayed').addEventListener('change', togglePlayedFilter);
    document.getElementById('undo').addEventListener('click', undo);

    // Session input handlers
    const buyInInput = document.getElementById('buyInInput');
    if (buyInInput) {
      buyInInput.addEventListener('change', function() {
        PokerTracker.DataStore.updateSession(currentSessionId, { buyIn: parseFloat(this.value) || 0 });
        updateSessionStats();
      });
    }

    const cashOutInput = document.getElementById('cashOutInput');
    if (cashOutInput) {
      cashOutInput.addEventListener('change', function() {
        PokerTracker.DataStore.updateSession(currentSessionId, { cashOut: parseFloat(this.value) || 0 });
        updateSessionStats();
      });
    }

    const gameSelectForListener = document.getElementById('gameSelect');
    if (gameSelectForListener) {
      gameSelectForListener.addEventListener('change', function() {
        PokerTracker.DataStore.updateSession(currentSessionId, { gameId: this.value });
        updateSessionStats();
      });
    }

    const startTimeInput = document.getElementById('startTimeInput');
    if (startTimeInput) {
      startTimeInput.addEventListener('change', function() {
        PokerTracker.DataStore.updateSession(currentSessionId, { startTime: new Date(this.value).toISOString() });
      });
    }

    const endTimeInput = document.getElementById('endTimeInput');
    if (endTimeInput) {
      endTimeInput.addEventListener('change', function() {
        PokerTracker.DataStore.updateSession(currentSessionId, { endTime: new Date(this.value).toISOString() });
      });
    }

    const sessionNotes = document.getElementById('sessionNotes');
    if (sessionNotes) {
      sessionNotes.addEventListener('change', function() {
        PokerTracker.DataStore.updateSessionNotes(currentSessionId, this.value);
      });
    }

    // Responsive events
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(fitGridToViewport, 100);
    }, { passive: true });

    window.addEventListener('orientationchange', () => {
      setTimeout(fitGridToViewport, 200);
    });

    // Initialize with grid view
    switchView('grid');
  });

  // Keep these legacy function names for compatibility
  function undoLastHand() {
    undo();
  }

  function endSession() {
    const session = getCurrentSession();
    if (!session) return;

    const activeSession = PokerTracker.DataStore.getActiveSession();
    const isLiveSession = activeSession && activeSession.id === session.id;

    if (isLiveSession) {
      if (confirm('End this live session? This will mark it as completed.')) {
        PokerTracker.DataStore.endLiveSession();
        updateSessionStats();

        // Update nav link globally
        if (window.updateLiveSessionNavLink) {
          window.updateLiveSessionNavLink();
        }

        window.location.href = '/projects/poker_tracker/sessions';
      }
    } else {
      if (confirm('Return to sessions page?')) {
        window.location.href = '/projects/poker_tracker/sessions';
      }
    }
  }

  function editSessionName() {
    const titleElement = document.getElementById('sessionTitle');
    const inputElement = document.getElementById('sessionNameInput');

    inputElement.value = titleElement.textContent.replace('Session: ', '');
    titleElement.style.display = 'none';
    inputElement.style.display = 'block';
    inputElement.focus();
    inputElement.select();
  }

  function saveSessionName() {
    const titleElement = document.getElementById('sessionTitle');
    const inputElement = document.getElementById('sessionNameInput');

    const newName = inputElement.value.trim() || 'Session Details';
    titleElement.textContent = `Session: ${newName}`;

    titleElement.style.display = 'block';
    inputElement.style.display = 'none';

    // Save to data store
    if (currentSessionId) {
      PokerTracker.DataStore.updateSession(currentSessionId, { name: newName });
    }
  }

  function handleSessionNameKeypress(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      saveSessionName();
    } else if (event.key === 'Escape') {
      const titleElement = document.getElementById('sessionTitle');
      const inputElement = document.getElementById('sessionNameInput');

      titleElement.style.display = 'block';
      inputElement.style.display = 'none';
    }
  }

</script>

<!-- Shared JavaScript -->
<script src="assets/js/data-store.js"></script>
<script src="assets/js/app.js"></script>

<script>
  function quickAction() {
    if (currentSessionId) {
      const sessionData = PokerTracker.DataStore.getSessionData(currentSessionId);
      if (sessionData.total > 0) {
        document.getElementById('viewTabs').style.display = 'flex';
        switchView(currentView === 'grid' ? 'list' : 'grid');
      }
    }
  }
</script>


  </main>

  {% include_relative components/new-session-modal.html %}
  {% include_relative components/new-game-modal.html %}
  {% include_relative components/session-settings-modal.html %}
</body>
</html>
